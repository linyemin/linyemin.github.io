<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.3">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="tensorflow,rdma," />










<meta name="description" content="rdma.cc">
<meta name="keywords" content="tensorflow,rdma">
<meta property="og:type" content="article">
<meta property="og:title" content="TensorFlow中rdma的使用">
<meta property="og:url" content="http://yoursite.com/2017/09/14/tensorflow-rdma-code/index.html">
<meta property="og:site_name" content="林烨敏的博客">
<meta property="og:description" content="rdma.cc">
<meta property="og:locale" content="zh-Hans">
<meta property="og:updated_time" content="2017-11-30T12:01:00.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="TensorFlow中rdma的使用">
<meta name="twitter:description" content="rdma.cc">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2017/09/14/tensorflow-rdma-code/"/>





  <title>TensorFlow中rdma的使用 | 林烨敏的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">林烨敏的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2017/09/14/tensorflow-rdma-code/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="linyemin">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="林烨敏的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">TensorFlow中rdma的使用</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-14T15:59:32+08:00">
                2017-09-14
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/tensorflow/" itemprop="url" rel="index">
                    <span itemprop="name">tensorflow</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <h1 id="rdma-cc"><a href="#rdma-cc" class="headerlink" title="rdma.cc"></a>rdma.cc</h1><a id="more"></a>
<h2 id="相关结构体"><a href="#相关结构体" class="headerlink" title="相关结构体"></a>相关结构体</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// structure to save the address of remote channels.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RdmaAddress</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint32_t</span> lid;</span><br><span class="line">  <span class="keyword">uint32_t</span> qpn;</span><br><span class="line">  <span class="keyword">uint32_t</span> psn;</span><br><span class="line">  <span class="keyword">uint64_t</span> snp;</span><br><span class="line">  <span class="keyword">uint64_t</span> iid;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// structure to save information for remote memory regions.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">RemoteMR</span> &#123;</span></span><br><span class="line">  <span class="keyword">uint64_t</span> remote_addr;</span><br><span class="line">  <span class="keyword">uint32_t</span> rkey;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">enum</span> BufferStatus &#123; none, idle, busy &#125;;</span><br><span class="line"><span class="keyword">enum</span> Location &#123; local, remote &#125;;</span><br><span class="line"><span class="keyword">enum</span> BufferType &#123; ACK, MESSAGE, TENSOR &#125;;</span><br><span class="line"><span class="keyword">enum</span> RdmaMessageType &#123;</span><br><span class="line">  RDMA_MESSAGE_ACK,</span><br><span class="line">  RDMA_MESSAGE_BUFFER_IDLE,</span><br><span class="line">  RDMA_MESSAGE_BUFFER_REQUEST,</span><br><span class="line">  RDMA_MESSAGE_BUFFER_RESPONSE,</span><br><span class="line">  RDMA_MESSAGE_TENSOR_REQUEST,</span><br><span class="line">  RDMA_MESSAGE_TENSOR_WRITE</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="RdmaAdapter"><a href="#RdmaAdapter" class="headerlink" title="RdmaAdapter"></a>RdmaAdapter</h2><h3 id="RdmaAdapter-const-WorkerEnv-worker-env"><a href="#RdmaAdapter-const-WorkerEnv-worker-env" class="headerlink" title="RdmaAdapter(const WorkerEnv* worker_env)"></a>RdmaAdapter(const WorkerEnv* worker_env)</h3><ol>
<li>dev_list = ibv_get_device_list(NULL);获取主机可用的VPI设备列表</li>
<li>ib_dev = dev_list[0]默认取第一个设备</li>
<li>ibv_context* context = ibv_open_device(ib_dev);打开设备获取context</li>
<li>ibv_pd* pd = ibv_alloc_pd(context);创建Protection Domain</li>
<li>worker<em>env\</em> (worker_env)拷贝工作环境参数</li>
<li>event<em>channel\</em> = ibv_create_comp<em>channel(context\</em>);创建完成通道，用于通知完成队列</li>
<li>cq_ = ibv_create<em>cq(context\</em>, MAX_CONCURRENT_WRITES * 2, NULL, event<em>channel</em>, 0);创建完成队列</li>
<li>ibv_req_notify<em>cq(cq</em>, 0)完成完成队列与完成通道的关联</li>
<li>启动处理线程Process_CQ()</li>
</ol>
<h3 id="RdmaAdapter-1"><a href="#RdmaAdapter-1" class="headerlink" title="~RdmaAdapter()"></a>~RdmaAdapter()</h3><ol>
<li>ibv_destroy<em>cq(cq</em>)</li>
<li>ibv_destroy_comp_channel(event<em>channel</em>)</li>
<li>ibv_dealloc<em>pd(pd</em>)</li>
<li>ibv_close<em>device(context</em>)</li>
</ol>
<h3 id="void-Process-CQ"><a href="#void-Process-CQ" class="headerlink" title="void Process_CQ()"></a>void Process_CQ()</h3><ol>
<li>ibv_get_cq_event(event<em>channel</em>, &amp;cq, &amp;cq_context)阻塞等待队列中进入新元素</li>
<li>ibv_ack_cq_events(cq, 1);确认收到的事件</li>
<li>ibv_req_notify<em>cq(cq</em>, 0)重新注册，等待下次事件触发</li>
<li><code>int ne = ibv_poll_cq(cq\_, MAX_CONCURRENT_WRITES * 2, static_cast&lt;ibv_wc*&gt;(wc_));</code> 从CQ队列中获取所有的事件,ne表示事件个数</li>
<li>遍历每个cqe<ol>
<li>判断wc_[i].status == IBV_WC_SUCCESS，检查wr的状态是否正确</li>
<li>若wc_[i].opcode == IBV_WC_RECV_RDMA_WITH_IMM<ol>
<li>RdmaChannel<em> rc = reinterpret_cast&lt;RdmaChannel</em>&gt;(wc_[i].wr_id);若是接收事件，则wr_id中存放本地Channel的指针</li>
<li>rc-&gt;Recv();让channel做好接收的准备</li>
<li>RdmaBuffer* rb = rc-&gt;FindBuffer(wc_[i].imm_data); 利用imm_data来寻找buffer地址</li>
<li>RdmaMessage::ParseMessage(rm, rb-&gt;buffer_); 将buffer中的信息解析成Message</li>
<li>判断rm.type<ol>
<li>若rm.type_ == RDMA_MESSAGE_ACK<ol>
<li>将本地的tx_message<em>buffer</em>的remote状态设置为空闲。</li>
<li>本地tx_message<em>buffer</em>发送下一条Message</li>
</ol>
</li>
<li>若rm.type_ == RDMA_MESSAGE_TENSOR_REQUEST<ol>
<li>首先通过本地的tx_ack<em>buffer</em>发送ack，使得对方释放它的message buffer。</li>
<li>RdmaBuffer* tb = rc-&gt;FindOrCreateBuffer(rm.name_); 通过name来寻找buffer，此处的buffer为tensor buffer。</li>
<li>string key_with_step<em>id = VerbsUtil::AppendStepidToKey(rm.name\</em>, rm.step<em>id\</em>); 生成一个类似”tx_tensor_buffer123456”的标识符。</li>
<li>tb-&gt;EnqueueItem(key_with_step_id); 将此标识符放入处理队列中。</li>
<li>worker<em>env</em>-&gt;compute_pool-&gt;Schedule(<a href="">tb\</a> { tb-&gt;SendNextItem(); }); 设置定时任务，使得tx_tensor_buffer开始发送数据。</li>
</ol>
</li>
<li>若rm.type_ == RDMA_MESSAGE_BUFFER_IDLE<ol>
<li>首先通过本地的tx_ack<em>buffer</em>发送ack，使得对方释放它的message buffer。</li>
<li>RdmaBuffer* tb = rc-&gt;FindBuffer(rm.name_); 通过name来寻找tensor buffer。</li>
<li>设置此tx_tensor_buffer的remote状态为空闲，表示对方已经就绪。</li>
<li>设置定时任务，使得tx_tensor_buffer开始发送数据。</li>
</ol>
</li>
<li>若rm.type_ == RDMA_MESSAGE_BUFFER_REQUEST<ol>
<li>首先通过本地的tx_ack<em>buffer</em>发送ack，使得对方释放它的message buffer。</li>
<li>收到此消息时，表示发送方说“现有的tensor buffer不够大小了，我已经重新创建了，大小告诉你了，你也重新创一个，我们再建立连接。”</li>
<li>RdmaBuffer* tb = rc-&gt;FindOrCreateBuffer(rm.name_, TENSOR); 寻找这个tensor buffer，找到以后进行空间处理(tb-&gt;CreateCPUBuffer(rm.buffer<em>size\</em>);)、连接处理(tb-&gt;SetRemoteMR(rmr, true);)。</li>
<li>创建成功后，回复发送者说，我创建好了，你来跟我建立连接吧。准备发送RDMA_MESSAGE_BUFFER_RESPONSE消息。</li>
<li>通过tx_message_buffer发送此消息，消息入队。</li>
<li>tx_message_buffer开始发送下一条消息。</li>
</ol>
</li>
<li>若rm.type_ == RDMA_MESSAGE_BUFFER_RESPONSE<ol>
<li>首先通过本地的tx_ack<em>buffer</em>发送ack，使得对方释放它的message buffer。</li>
<li>寻找本地的tx_tensor_buffer，来和接收者建立链接。</li>
<li>将tx_tensor_buffer的local和remote状态都设置为空闲，准备发送数据。</li>
<li>设置定时任务，使得tx_tensor_buffer开始发送数据。</li>
</ol>
</li>
<li>若rm.type_ == RDMA_MESSAGE_TENSOR_WRITE<ol>
<li>设置定时任务，通过key_with_step_id (ex: “tx_tensor_buffer123456”)来运行指定的callback函数。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
<li>若wc_[i].opcode == IBV_WC_RDMA_WRITE<ol>
<li>RdmaBuffer<em> rb = reinterpret_cast&lt;RdmaBuffer</em>&gt;(wc_[i].wr_id);  若为本地后台发来的消息，则wr_id中存放buffer地址。一般为tx_message_buffer。</li>
<li>将该buffer的local状态设置为空闲。</li>
<li>解析buffer中的消息。</li>
<li>若buffer中的消息类型是RDMA_MESSAGE_ACK，则不做任何处理。否则创建定时任务，使得tx_message_buffer开始发送下一条数据。</li>
</ol>
</li>
</ol>
</li>
</ol>
<h2 id="RdmaChannel"><a href="#RdmaChannel" class="headerlink" title="RdmaChannel"></a>RdmaChannel</h2><h3 id="RdmaChannel-const-RdmaAdapter-adapter-const-string-local-name-const-string-remotename"><a href="#RdmaChannel-const-RdmaAdapter-adapter-const-string-local-name-const-string-remotename" class="headerlink" title="RdmaChannel(const RdmaAdapter* adapter, const string local_name, const string remotename)"></a>RdmaChannel(const RdmaAdapter* adapter, const string local_name, const string remote<em>name</em>)</h3><ol>
<li>qp_ = ibv_create<em>qp(adapter</em>-&gt;pd_, &amp;attr); 创建Queue Pair</li>
<li>ibv_modify<em>qp(qp</em>, &amp;attr, mask) 初始化QP</li>
<li>创建4个buffer并建立hash，同时加入索引表，tx_message<em>buffer</em> = new RdmaMessageBuffer(this, buffer_names[0]);</li>
<li>执行100次Recv() (ibv_post_recv())，使得buffer准备好接收。</li>
</ol>
<h3 id="RdmaChannel-1"><a href="#RdmaChannel-1" class="headerlink" title="~RdmaChannel()"></a>~RdmaChannel()</h3><ol>
<li>ibv_destroy<em>qp(qp</em>) 销毁QP</li>
<li>销毁buffer</li>
</ol>
<h2 id="TensorFlow相关"><a href="#TensorFlow相关" class="headerlink" title="TensorFlow相关"></a>TensorFlow相关</h2><h3 id="类关系"><a href="#类关系" class="headerlink" title="类关系"></a>类关系</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">core:refCounts=&gt;start: core:refCounts</span><br><span class="line">Rendezvous=&gt;start: Rendezvous</span><br><span class="line">RendezvousCond=&gt;condition: Derived Class</span><br><span class="line">LocalRendezvousImpl=&gt;start: LocalRendezvousImpl(.cc文件中)</span><br><span class="line">RemoteRendezvous=&gt;start: ReomoteRendezvous(纯虚类)</span><br><span class="line">BaseRemoteRendezvous=&gt;start: BaseRemoteRendezvous</span><br><span class="line">RdmaRemoteRedezvous=&gt;start: RdmaRemoteRedezvous</span><br><span class="line"></span><br><span class="line">core:refCounts-&gt;Rendezvous-&gt;RendezvousCond</span><br><span class="line">RendezvousCond(yes)-&gt;RemoteRendezvous-&gt;BaseRemoteRendezvous-&gt;RdmaRemoteRedezvous</span><br><span class="line">RendezvousCond(no)-&gt;LocalRendezvousImpl</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">RendezvousMgrInterface=&gt;start: RendezvousMgrInterface(纯虚类)</span><br><span class="line">BaseRendezvousMgr=&gt;start: BaseRendezvousMgr</span><br><span class="line">RdmaRendezvousMgr=&gt;start: RdmaRendezvousMgr</span><br><span class="line"></span><br><span class="line">RendezvousMgrInterface-&gt;BaseRendezvousMgr-&gt;RdmaRendezvousMgr</span><br></pre></td></tr></table></figure>
<h3 id="初始化过程"><a href="#初始化过程" class="headerlink" title="初始化过程"></a>初始化过程</h3><ol>
<li><p>verbs_server_lib.cc文件中存在静态变量 <code>static VerbsServerRegistrar registrar;</code></p>
</li>
<li><p>该静态变量的构造函数中包含VERBS_SERVER服务的注册，和VerbsServerFactory服务对象的创建。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerbsServerRegistrar</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  VerbsServerRegistrar() &#123;</span><br><span class="line">    gpr_allocation_functions alloc_fns;</span><br><span class="line">    alloc_fns.malloc_fn = port::Malloc;</span><br><span class="line">    alloc_fns.realloc_fn = port::Realloc;</span><br><span class="line">    alloc_fns.free_fn = port::Free;</span><br><span class="line">    gpr_set_allocation_functions(alloc_fns);</span><br><span class="line">    ServerFactory::Register(<span class="string">"VERBS_SERVER"</span>, <span class="keyword">new</span> VerbsServerFactory());</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* static */</span></span><br><span class="line"><span class="keyword">void</span> ServerFactory::Register(<span class="keyword">const</span> <span class="built_in">string</span>&amp; server_type,</span><br><span class="line">                             ServerFactory* factory) &#123;</span><br><span class="line">  mutex_lock l(*get_server_factory_lock());</span><br><span class="line">  <span class="keyword">if</span> (!server_factories()-&gt;insert(&#123;server_type, factory&#125;).second) &#123;</span><br><span class="line">    LOG(ERROR) &lt;&lt; <span class="string">"Two server factories are being registered under "</span></span><br><span class="line">               &lt;&lt; server_type;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>VerbsServerFactory类的重写函数中包含VerbsServer的创建。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ServerInterface&gt; svr;</span><br><span class="line">TF_CHECK_OK(NewServer(server, &amp;svr));</span><br><span class="line">TF_CHECK_OK(svr-&gt;Start());</span><br><span class="line">TF_CHECK_OK(svr-&gt;Join());</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">VerbsServerFactory</span> :</span> <span class="keyword">public</span> ServerFactory &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">AcceptsOptions</span><span class="params">(<span class="keyword">const</span> ServerDef&amp; server_def)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> server_def.protocol() == <span class="string">"grpc+verbs"</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function">Status <span class="title">NewServer</span><span class="params">(<span class="keyword">const</span> ServerDef&amp; server_def,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ServerInterface&gt;* out_server)</span> override </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> VerbsServer::Create(server_def, Env::Default(), out_server);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
<li><p>VerbsServer::Create是静态函数，该函数中包含对VerbsService类的对象化、VerbsServer的对象化以及INIT和RdmaRendezvousMgr的对象化(RdmaRemoteRendezvous类被TF_DISALLOW_COPY_AND_ASSIGN修饰，导致RdmaRemoteRendezvous类的拷贝构造函数和复制构造函数为私有)。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* static */</span></span><br><span class="line">Status VerbsServer::Create(<span class="keyword">const</span> ServerDef&amp; server_def, Env* env,</span><br><span class="line">                           <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;ServerInterface&gt;* out_server) &#123;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">unique_ptr</span>&lt;VerbsServer&gt; ret(<span class="keyword">new</span> VerbsServer(server_def, Env::Default()));</span><br><span class="line">  ServiceInitFunction service_func = [&amp;ret](<span class="keyword">const</span> WorkerEnv* worker_env,</span><br><span class="line">                                            ::grpc::ServerBuilder* builder) &#123;</span><br><span class="line">    <span class="keyword">return</span> SetNewVerbsService(&amp;ret-&gt;verbs_service_, worker_env, builder);</span><br><span class="line">  &#125;;</span><br><span class="line">  TF_RETURN_IF_ERROR(ret-&gt;Init(service_func, NewRdmaRendezvousMgr));</span><br><span class="line">  *out_server = <span class="built_in">std</span>::move(ret);</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">RendezvousMgrInterface* <span class="title">NewRdmaRendezvousMgr</span><span class="params">(<span class="keyword">const</span> WorkerEnv* env)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> RdmaRendezvousMgr(env);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status VerbsServer::Init(ServiceInitFunction service_func,</span><br><span class="line">                         RendezvousMgrCreationFunction rendezvous_mgr_func) &#123;</span><br><span class="line">  Status s = GrpcServer::Init(service_func, rendezvous_mgr_func);</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">mutex_lock <span class="title">l</span><span class="params">(mu_)</span></span>;</span><br><span class="line">    CHECK_EQ(verbs_state_, DISCONNECTED);</span><br><span class="line">    CHECK(ChannelCacheFactory(server_def(), &amp;channel_cache_).ok());</span><br><span class="line">    rdma_mgr_ = <span class="keyword">new</span> RdmaMgr(worker_env(), channel_cache_);</span><br><span class="line">    <span class="comment">// set rdma_mgr for verbs_service and rdma_rendezvous_mgr</span></span><br><span class="line">    verbs_service_-&gt;SetRdmaMgr(rdma_mgr_);</span><br><span class="line">    <span class="keyword">dynamic_cast</span>&lt;RdmaRendezvousMgr*&gt;(worker_env()-&gt;rendezvous_mgr)</span><br><span class="line">        -&gt;SetRdmaMgr(rdma_mgr_);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Create a GrpcVerbsService, then assign it to a given handle.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">SetNewVerbsService</span><span class="params">(GrpcVerbsService** handle, <span class="keyword">const</span> WorkerEnv* worker_env,</span></span></span><br><span class="line"><span class="function"><span class="params">                        ::grpc::ServerBuilder* builder)</span> </span>&#123;</span><br><span class="line">  *handle = <span class="keyword">new</span> GrpcVerbsService(worker_env, builder);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">RdmaMgr::RdmaMgr(<span class="keyword">const</span> WorkerEnv* <span class="keyword">const</span> worker_env,</span><br><span class="line">                 GrpcChannelCache* <span class="keyword">const</span> channel_cache)</span><br><span class="line">    : worker_env_(worker_env), channel_cache_(channel_cache) &#123;</span><br><span class="line">  rdma_adapter_ = <span class="keyword">new</span> RdmaAdapter(worker_env_);</span><br><span class="line">  <span class="comment">// hardcoded to default session (legacy_session_)</span></span><br><span class="line">  <span class="comment">// <span class="doctag">TODO:</span> use WorkerSessionForSession</span></span><br><span class="line">  <span class="comment">// need to pass in session handle</span></span><br><span class="line">  local_worker_ = worker_env_-&gt;session_mgr-&gt;LegacySession()-&gt;worker_name;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; workers;</span><br><span class="line">  worker_env_-&gt;session_mgr-&gt;LegacySession()-&gt;worker_cache-&gt;ListWorkers(</span><br><span class="line">      &amp;workers);</span><br><span class="line">  num_remote_workers_ = workers.size() - <span class="number">1</span>;</span><br><span class="line">  VLOG(<span class="number">2</span>) &lt;&lt; <span class="string">"rmda_mgr on local worker: "</span> &lt;&lt; local_worker_;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; workers.size(); i++) &#123;</span><br><span class="line">    <span class="keyword">if</span> (local_worker_.compare(workers[i]) != <span class="number">0</span>) &#123;</span><br><span class="line">      channel_table_.insert(</span><br><span class="line">          &#123;workers[i],</span><br><span class="line">           <span class="keyword">new</span> RdmaChannel(rdma_adapter_, local_worker_, workers[i])&#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>VerbsServer的Start函数，包含了gRPC线程的创建和Channel的设置。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">Status VerbsServer::Start() &#123;</span><br><span class="line">  Status s = GrpcServer::Start();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">mutex_lock <span class="title">l</span><span class="params">(mu_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (verbs_state_ == DISCONNECTED) &#123;</span><br><span class="line">      <span class="comment">// verbs_thread needs to be initiated</span></span><br><span class="line">      <span class="comment">// before rdma_mgr sets up the rdma channels.</span></span><br><span class="line">      verbs_thread_.reset(worker_env()-&gt;env-&gt;StartThread(</span><br><span class="line">          ThreadOptions(), <span class="string">"TF_verbs_service"</span>,</span><br><span class="line">          [<span class="keyword">this</span>] &#123; verbs_service_-&gt;HandleRPCsLoop(); &#125;));</span><br><span class="line">      rdma_mgr_-&gt;SetupChannels();</span><br><span class="line">      verbs_state_ = CONNECTED;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This method blocks forever handling requests from the completion queue.</span></span><br><span class="line"><span class="keyword">void</span> GrpcVerbsService::HandleRPCsLoop() &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; ++i) &#123;</span><br><span class="line">    ENQUEUE_REQUEST(GetRemoteAddress, <span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">void</span>* tag;</span><br><span class="line">  <span class="keyword">bool</span> ok;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (cq_-&gt;Next(&amp;tag, &amp;ok)) &#123;</span><br><span class="line">    UntypedCall&lt;GrpcVerbsService&gt;::Tag* callback_tag =</span><br><span class="line">        <span class="keyword">static_cast</span>&lt;UntypedCall&lt;GrpcVerbsService&gt;::Tag*&gt;(tag);</span><br><span class="line">    <span class="keyword">if</span> (callback_tag) &#123;</span><br><span class="line">      callback_tag-&gt;OnCompleted(<span class="keyword">this</span>, ok);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      cq_-&gt;Shutdown();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>VerbsServer的Join函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">Status VerbsServer::Join() &#123;</span><br><span class="line">  Status s = GrpcServer::Join();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">mutex_lock <span class="title">l</span><span class="params">(mu_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (verbs_state_ == CONNECTED) &#123;</span><br><span class="line">      verbs_state_ = DISCONNECTED;</span><br><span class="line">      verbs_thread_.reset();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status GrpcServer::Join() &#123;</span><br><span class="line">  <span class="function">mutex_lock <span class="title">l</span><span class="params">(mu_)</span></span>;</span><br><span class="line">  <span class="keyword">switch</span> (state_) &#123;</span><br><span class="line">    <span class="keyword">case</span> NEW:</span><br><span class="line">      <span class="comment">// Prevent the server from being started subsequently.</span></span><br><span class="line">      state_ = STOPPED;</span><br><span class="line">      <span class="keyword">return</span> Status::OK();</span><br><span class="line">    <span class="keyword">case</span> STARTED:</span><br><span class="line">    <span class="keyword">case</span> STOPPED:</span><br><span class="line">      master_thread_.reset();</span><br><span class="line">      worker_thread_.reset();</span><br><span class="line">      <span class="keyword">return</span> Status::OK();</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      CHECK(<span class="literal">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<h3 id="Rendezvous"><a href="#Rendezvous" class="headerlink" title="Rendezvous"></a>Rendezvous</h3><p>Rendezvous的基类为core::RefCounted，声明如下</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">namespace</span> core &#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 自动回收机制</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RefCounted</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Initial reference count is one.</span></span><br><span class="line">  RefCounted();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Increments reference count by one.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Ref</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Decrements reference count by one.  If the count remains</span></span><br><span class="line">  <span class="comment">// positive, returns false.  When the count reaches zero, returns</span></span><br><span class="line">  <span class="comment">// true and deletes this, in which case the caller must not access</span></span><br><span class="line">  <span class="comment">// the object afterward.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">Unref</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Return whether the reference count is one.</span></span><br><span class="line">  <span class="comment">// If the reference count is used in the conventional way, a</span></span><br><span class="line">  <span class="comment">// reference count of 1 implies that the current thread owns the</span></span><br><span class="line">  <span class="comment">// reference and no other thread shares it.</span></span><br><span class="line">  <span class="comment">// This call performs the test for a reference count of one, and</span></span><br><span class="line">  <span class="comment">// performs the memory barrier needed for the owning thread</span></span><br><span class="line">  <span class="comment">// to act on the object, knowing that it has exclusive access to the</span></span><br><span class="line">  <span class="comment">// object.</span></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">RefCountIsOne</span><span class="params">()</span> <span class="keyword">const</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// Make destructor protected so that RefCounted objects cannot</span></span><br><span class="line">  <span class="comment">// be instantiated directly. Only subclasses can be instantiated.</span></span><br><span class="line">  <span class="keyword">virtual</span> ~RefCounted();</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">mutable</span> <span class="built_in">std</span>::<span class="keyword">atomic_int_fast32_t</span> ref_;</span><br><span class="line"></span><br><span class="line">  RefCounted(<span class="keyword">const</span> RefCounted&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">  <span class="keyword">void</span> <span class="keyword">operator</span>=(<span class="keyword">const</span> RefCounted&amp;) = <span class="keyword">delete</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Rendezvous 类声明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// A Rendezvous is an abstraction for passing a Tensor</span></span><br><span class="line"><span class="comment">// from a producer to a consumer, where the consumer may safely</span></span><br><span class="line"><span class="comment">// request the Tensor before or after it has been produced.  A</span></span><br><span class="line"><span class="comment">// producer never blocks when using a Rendezvous.  A consumer has the</span></span><br><span class="line"><span class="comment">// choice of making a blocking call or providing a callback: in either</span></span><br><span class="line"><span class="comment">// case, the consumer receives the Tensor as soon as it is available.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// A Rendezvous key encodes a single &lt;producer, consumer&gt; pair.  It is</span></span><br><span class="line"><span class="comment">// an error to call Send() or Recv*() more than once with the same</span></span><br><span class="line"><span class="comment">// key.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Rendezvous</span> :</span> <span class="keyword">public</span> core::RefCounted &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">Args</span> &#123;</span></span><br><span class="line">    DeviceContext* device_context = <span class="literal">nullptr</span>;</span><br><span class="line">    AllocatorAttributes alloc_attrs;</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Constructs a rendezvous key for the tensor of "name" sent from</span></span><br><span class="line">  <span class="comment">// "src_device" to "dst_device". The tensor is generated in the frame</span></span><br><span class="line">  <span class="comment">// and iteration specified by "frame_iter".</span></span><br><span class="line">  <span class="function"><span class="keyword">static</span> <span class="built_in">string</span> <span class="title">CreateKey</span><span class="params">(<span class="keyword">const</span> <span class="built_in">string</span>&amp; src_device, uint64 src_incarnation,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> <span class="built_in">string</span>&amp; dst_device, <span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> FrameAndIter&amp; frame_iter)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Parses the key constructed by CreateKey and parse src/dst device</span></span><br><span class="line">  <span class="comment">// names into structures respectively.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ParsedKey</span> &#123;</span></span><br><span class="line">    StringPiece src_device;</span><br><span class="line">    DeviceNameUtils::ParsedName src;</span><br><span class="line">    uint64 src_incarnation = <span class="number">0</span>;</span><br><span class="line">    StringPiece dst_device;</span><br><span class="line">    DeviceNameUtils::ParsedName dst;</span><br><span class="line">    StringPiece edge_name;</span><br><span class="line"></span><br><span class="line">    ParsedKey() &#123;&#125;</span><br><span class="line">    ParsedKey(<span class="keyword">const</span> ParsedKey&amp; b) &#123; *<span class="keyword">this</span> = b; &#125;</span><br><span class="line"></span><br><span class="line">    ParsedKey&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ParsedKey&amp; b);</span><br><span class="line">    <span class="function">StringPiece <span class="title">FullKey</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buf_; &#125;</span><br><span class="line"></span><br><span class="line">   <span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Rendezvous</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SendOp</span>;</span></span><br><span class="line">    <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">RecvOp</span>;</span></span><br><span class="line">    <span class="built_in">string</span> buf_;</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="function"><span class="keyword">static</span> Status <span class="title">ParseKey</span><span class="params">(StringPiece key, ParsedKey* out)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The caller is a tensor producer and it sends a message (a tensor</span></span><br><span class="line">  <span class="comment">// "val" and a bool "is_dead") under the given "key".</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// &#123;val, is_dead&#125; is bundled as a message sent and received.</span></span><br><span class="line">  <span class="comment">// Typically, is_dead is set by some control flow nodes</span></span><br><span class="line">  <span class="comment">// (e.g., a not-taken branch).  args is passed by Send to the</span></span><br><span class="line">  <span class="comment">// Recv function to communicate any information that the Recv</span></span><br><span class="line">  <span class="comment">// function might need.  This is typically only necessary for</span></span><br><span class="line">  <span class="comment">// Send/Recv on the same worker.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Send() never blocks.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Send</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; args, <span class="keyword">const</span> Tensor&amp; val,</span></span></span><br><span class="line"><span class="function"><span class="params">                      <span class="keyword">const</span> <span class="keyword">bool</span> is_dead)</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Callback provided by a tensor consumer waiting on the rendezvous.</span></span><br><span class="line">  <span class="comment">// It will be invoked when the tensor is available, or when a non-OK</span></span><br><span class="line">  <span class="comment">// status arises in the production of that tensor.  It also gets</span></span><br><span class="line">  <span class="comment">// two Rendezvous::Args, one provided by the sender, the other by the</span></span><br><span class="line">  <span class="comment">// receiver, which may be needed when a non-CPU device is in use</span></span><br><span class="line">  <span class="comment">// by either side.</span></span><br><span class="line">  <span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> Status&amp;, <span class="keyword">const</span> Args&amp;, <span class="keyword">const</span> Args&amp;,</span><br><span class="line">                             <span class="keyword">const</span> Tensor&amp;, <span class="keyword">const</span> <span class="keyword">bool</span>)&gt;</span><br><span class="line">      DoneCallback;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RecvAsync</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                         DoneCallback done)</span> </span>= <span class="number">0</span>; <span class="comment">// 纯虚函数</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Synchronous wrapper for RecvAsync.</span></span><br><span class="line">  <span class="function">Status <span class="title">Recv</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; args, Tensor* val,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">bool</span>* is_dead, int64 timeout_ms)</span></span>;</span><br><span class="line">  <span class="function">Status <span class="title">Recv</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; args, Tensor* val,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">bool</span>* is_dead)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Aborts all pending and future Send/Recv with the given "status".</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// StartAbort() does not wait for ongoing calls to finish.</span></span><br><span class="line">  <span class="comment">// REQUIRES: !status.ok()</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">StartAbort</span><span class="params">(<span class="keyword">const</span> Status&amp; status)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  ~Rendezvous() override;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>rendezvous.cc中包含了class LocalRendezvousImpl实现，实现了Send和RecvAsync的具体实现。对外提供了如下接口：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 具体定义，在cc文件中</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LocalRendezvousImpl</span> :</span> <span class="keyword">public</span> Rendezvous &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rendezvous.h中的接口在cc文件中的实现</span></span><br><span class="line"><span class="function">Rendezvous* <span class="title">NewLocalRendezvous</span><span class="params">(<span class="keyword">bool</span> tolerate_dup_recv)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> LocalRendezvousImpl(tolerate_dup_recv);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rendezvous的一个子类RemoteRendezvous为纯虚类</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoteRendezvous follow a 2-part initialization. First the objects are</span></span><br><span class="line"><span class="comment">// constructed. Eventually, they will be initialized. Clients of the</span></span><br><span class="line"><span class="comment">// RendezvousMgrInterface must guarantee to call Initialize on the returned</span></span><br><span class="line"><span class="comment">// RemoteRendezvous eventually.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Partially initialized RemoteRendezvous must respect the Rendezvous interface</span></span><br><span class="line"><span class="comment">// (i.e. Send() must never block), however implementations are not expected to</span></span><br><span class="line"><span class="comment">// actually perform the underlying operations until after the RemoteRendezvous</span></span><br><span class="line"><span class="comment">// has been Initialize'd.</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// RemoteRendezvous遵循2部分的初始化。首先构建对象。最终，它们将被初始化。 RendezvousMgrInterface的客户端必须保证最终在返回的RemoteRendezvous上调用Initialize。</span></span><br><span class="line"><span class="comment">//部分初始化RemoteRendezvous必须遵循Rendezvous接口（即Send（）不能阻塞），但是在RemoteRendezvous被初始化之前，实现不会实际执行底层操作。</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RemoteRendezvous</span> :</span> <span class="keyword">public</span> Rendezvous &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// Fully construct the RemoteRendezvous.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">Initialize</span><span class="params">(WorkerSession* session)</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>RemoteRendezvous类的子类BaseRemoteRendezvous</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RemoteRendezvous is a Rendezvous which can handle either</span></span><br><span class="line"><span class="comment">// the producer or consumer being in a remote process.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Buffering of Tensor values is delegated to a "local" Rendezvous</span></span><br><span class="line"><span class="comment">// obtained from NewLocalRendezvous().  This class just adds</span></span><br><span class="line"><span class="comment">// functionality to coordinate with remote workers.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRemoteRendezvous</span> :</span> <span class="keyword">public</span> RemoteRendezvous &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  BaseRemoteRendezvous(<span class="keyword">const</span> WorkerEnv* env, int64 step_id,</span><br><span class="line">                       <span class="keyword">bool</span> tolerate_dup_recv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Upgrades the BaseRemoteRendezvous to full initialization.</span></span><br><span class="line">  <span class="function">Status <span class="title">Initialize</span><span class="params">(WorkerSession* session)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Forwards to local_, where the Tensor "val" will be buffered and</span></span><br><span class="line">  <span class="comment">// any waiting callback stored.</span></span><br><span class="line">  <span class="function">Status <span class="title">Send</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Rendezvous::Args&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">              <span class="keyword">const</span> Tensor&amp; val, <span class="keyword">const</span> <span class="keyword">bool</span> is_dead)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This method is called only by the RecvOp.  It tests to see</span></span><br><span class="line">  <span class="comment">// whether the value will be produced by a local or remote device</span></span><br><span class="line">  <span class="comment">// and handles accordingly.  In the local case it forwards to</span></span><br><span class="line">  <span class="comment">// local_, in the remote case it initiates an RPC request.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RecvAsync</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Rendezvous::Args&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                 DoneCallback done)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">StartAbort</span><span class="params">(<span class="keyword">const</span> Status&amp; status)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// This method is called only by the local Worker, forwarded through</span></span><br><span class="line">  <span class="comment">// the same method on RendezvousMgr.  This occurs when the Worker</span></span><br><span class="line">  <span class="comment">// has received a RecvTensor request, either locally or over the</span></span><br><span class="line">  <span class="comment">// network.  In either case it needs to retrieve a locally buffered</span></span><br><span class="line">  <span class="comment">// value from local_, and give it to its caller.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Runs "done" as soon as the tensor for "parsed" is available or an error</span></span><br><span class="line">  <span class="comment">// is detected.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// REQUIRES: "parsed" is one that will be Saved into the local rendezvous.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RecvLocalAsync</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; parsed, DoneCallback done)</span></span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RecvFromRemoteAsync</span><span class="params">(<span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   <span class="keyword">const</span> Rendezvous::Args&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   DoneCallback done)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns true if "src" and "dst" are located in the same worker,</span></span><br><span class="line">  <span class="comment">// and hence may use a local rendezvous.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">bool</span> <span class="title">IsSameWorker</span><span class="params">(DeviceNameUtils::ParsedName src,</span></span></span><br><span class="line"><span class="function"><span class="params">                            DeviceNameUtils::ParsedName dst)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If aborted, aborts "call". Otherwise, adds "call" into active_.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RegisterCall</span><span class="params">(BaseRecvTensorCall* call)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Removes "call" from active_ if "call" is in active_.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">DeregisterCall</span><span class="params">(BaseRecvTensorCall* call)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">WorkerSession* <span class="title">session</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_initialized</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">  ~BaseRemoteRendezvous() override;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">const</span> WorkerEnv* <span class="keyword">const</span> env_;  <span class="comment">// Not owned.</span></span><br><span class="line">  <span class="keyword">const</span> int64 step_id_;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  Rendezvous* local_;  <span class="comment">// Owns a Ref on this object.</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">mutable</span> mutex mu_;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Status given by StartAbort() if any.</span></span><br><span class="line">  <span class="function">Status status_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;</span><br><span class="line">  <span class="function">WorkerSession* session_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;  <span class="comment">// Not owned.</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// Data structures to handle calls when partially initialized.</span></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">DeferredCall</span> &#123;</span></span><br><span class="line">    <span class="keyword">const</span> ParsedKey parsed;</span><br><span class="line">    DoneCallback done;</span><br><span class="line"></span><br><span class="line">    DeferredCall(<span class="keyword">const</span> ParsedKey&amp; parsed, DoneCallback done);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DeferredCall&gt; <span class="function">deferred_calls_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Active outstanding RecvTensor calls.</span></span><br><span class="line">  gtl::FlatSet&lt;BaseRecvTensorCall*&gt; <span class="function">active_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">bool</span> <span class="title">is_initialized_locked</span><span class="params">()</span> <span class="title">EXCLUSIVE_LOCKS_REQUIRED</span><span class="params">(mu_)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> session_ != <span class="literal">nullptr</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// If "is_src" is true, checks that the rendezvous key "parsed"'s</span></span><br><span class="line">  <span class="comment">// source is in this process. If "is_src" is false, checks that the</span></span><br><span class="line">  <span class="comment">// rendezvous key "parsed"'s destination is in this process.</span></span><br><span class="line">  <span class="function">Status <span class="title">ValidateDevices</span><span class="params">(<span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed, <span class="keyword">bool</span> is_src)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Callback handling the case when a rendezvous has been</span></span><br><span class="line">  <span class="comment">// accomplished in local_ and the consumer is local to this process.</span></span><br><span class="line">  <span class="comment">// Tensor "in" will be copied into "out". The key "parsed" encodes</span></span><br><span class="line">  <span class="comment">// the src and dst devices.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SameWorkerRecvDone</span><span class="params">(<span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Rendezvous::Args&amp; in_args,</span></span></span><br><span class="line"><span class="function"><span class="params">                          <span class="keyword">const</span> Rendezvous::Args&amp; out_args, <span class="keyword">const</span> Tensor&amp; in,</span></span></span><br><span class="line"><span class="function"><span class="params">                          Tensor* out, StatusCallback done)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Must be called only if fully initialized.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RecvLocalAsyncInternal</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; parsed, DoneCallback done)</span></span>;</span><br><span class="line"></span><br><span class="line">  TF_DISALLOW_COPY_AND_ASSIGN(BaseRemoteRendezvous);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>在rdma_rendezvous_mgr.cc文件中声明且定义了RdmaRemoteRendezvous子类，RdmaRemoteRendezvous不对外开放</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RdmaRemoteRendezvous</span> :</span> <span class="keyword">public</span> BaseRemoteRendezvous &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  RdmaRemoteRendezvous(<span class="keyword">const</span> WorkerEnv* env,</span><br><span class="line">                       int64 step_id, RdmaMgr* rdma_mgr)</span><br><span class="line">      : BaseRemoteRendezvous(env, step_id, <span class="literal">true</span>),</span><br><span class="line">        rdma_mgr_(rdma_mgr) &#123;&#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RecvFromRemoteAsync</span><span class="params">(<span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                           <span class="keyword">const</span> Rendezvous::Args&amp; args,</span></span></span><br><span class="line"><span class="function"><span class="params">                           DoneCallback done)</span> override</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  ~RdmaRemoteRendezvous() override &#123;&#125;</span><br><span class="line">  RdmaMgr* rdma_mgr_;</span><br><span class="line"></span><br><span class="line">  TF_DISALLOW_COPY_AND_ASSIGN(RdmaRemoteRendezvous);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="RendezvousMgr"><a href="#RendezvousMgr" class="headerlink" title="RendezvousMgr"></a>RendezvousMgr</h3><p>虚基类RendezvousMgrInterface，无具体实现</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RendezvousMgr keeps track of a set of local rendezvous instances.</span></span><br><span class="line"><span class="comment">// All tensors sent by this worker are buffered in a RendezvousMgr</span></span><br><span class="line"><span class="comment">// until the tensor is received.  Each global unique "step_id"</span></span><br><span class="line"><span class="comment">// corresponds to one local rendezvous instance managed by a</span></span><br><span class="line"><span class="comment">// RendezvousMgr.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// E.g.,</span></span><br><span class="line"><span class="comment">//   Rendezvous* rendez = worker_env-&gt;rendezvous_mgr-&gt;Find(0x8935);</span></span><br><span class="line"><span class="comment">//   fork execution of an graph executor using "rendez"  on thread 1;</span></span><br><span class="line"><span class="comment">//   fork execution of another graph executor using "rendez" on thread 2;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   join threads 1 and 2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In the example above, execution in thread 1 and 2 communicates with</span></span><br><span class="line"><span class="comment">// each other by send/recv operations through the "rend".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Tensors sent and recved through rendezvous managed by this</span></span><br><span class="line"><span class="comment">// RendezvousMgr must have keys generated by Rendezvous::CreateKey.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RendezvousMgrInterface</span> &#123;</span></span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  RendezvousMgrInterface() &#123;&#125;</span><br><span class="line">  <span class="keyword">virtual</span> ~RendezvousMgrInterface() &#123;&#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns Rendezvous supporting send and recv among workers in the</span></span><br><span class="line">  <span class="comment">// "step_id".  The caller takes ownership of one reference on the</span></span><br><span class="line">  <span class="comment">// returned Rendezvous instance.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note: the caller must guarantee to eventually call Initialize on the</span></span><br><span class="line">  <span class="comment">// returned RemoteRendezvous</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> RemoteRendezvous* <span class="title">Find</span><span class="params">(int64 step_id)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finds the local rendezvous instance for the "step_id".  Runs</span></span><br><span class="line">  <span class="comment">// "done" when the tensor for "key" is produced or an error occurs.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This method is used by the rpc handler of RecvTensor.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">RecvLocalAsync</span><span class="params">(int64 step_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                              <span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                              Rendezvous::DoneCallback done)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Synchronous wrapper for RecvLocalAsync.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> Status <span class="title">RecvLocal</span><span class="params">(int64 step_id, <span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                           Tensor* val, <span class="keyword">bool</span>* is_dead)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Removes rendezvous for "step_id".</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TODO(zhifengc): Have a background thread in worker that</span></span><br><span class="line">  <span class="comment">// periodically calls CleanupAll().</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">(int64 step_id)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Removes all rendezvous.</span></span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">CleanupAll</span><span class="params">()</span> </span>= <span class="number">0</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>RendezvousMgrInterface的子类 BaseRendezvousMgr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RendezvousMgr keeps track of a set of local rendezvous instances.</span></span><br><span class="line"><span class="comment">// All tensors sent by this worker are buffered in a RendezvousMgr</span></span><br><span class="line"><span class="comment">// until the tensor is received.  Each global unique "step_id"</span></span><br><span class="line"><span class="comment">// corresponds to one local rendezvous instance managed by a</span></span><br><span class="line"><span class="comment">// RendezvousMgr.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// E.g.,</span></span><br><span class="line"><span class="comment">//   Rendezvous* rendez = worker_env-&gt;rendezvous_mgr-&gt;Find(0x8935);</span></span><br><span class="line"><span class="comment">//   fork execution of a graph executor using "rendez" on thread 1;</span></span><br><span class="line"><span class="comment">//   fork execution of another graph executor using "rendez" on thread 2;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   join threads 1 and 2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In the example above, execution in thread 1 and 2 communicates with</span></span><br><span class="line"><span class="comment">// each other by send/recv operations through `rendez`.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Tensors sent and received through a rendezvous managed by this</span></span><br><span class="line"><span class="comment">// RendezvousMgr must have keys generated by Rendezvous::CreateKey().</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">BaseRendezvousMgr</span> :</span> <span class="keyword">public</span> RendezvousMgrInterface &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="comment">// 将worker_env赋值给类的成员变量worker_env_</span></span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">BaseRendezvousMgr</span><span class="params">(<span class="keyword">const</span> WorkerEnv* worker_env)</span></span>;</span><br><span class="line">  <span class="comment">// 释放Table中所有的BaseRemoteRendezvous</span></span><br><span class="line">  ~BaseRendezvousMgr() override;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Returns Rendezvous supporting send and recv among workers in the</span></span><br><span class="line">  <span class="comment">// "step_id".  The caller takes ownership of one reference on the</span></span><br><span class="line">  <span class="comment">// returned Rendezvous instance.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// Note: the caller must guarantee to eventually call Initialize on the</span></span><br><span class="line">  <span class="comment">// returned RemoteRendezvous</span></span><br><span class="line">  <span class="comment">// 调用私有函数FindOrCreate，在调用这个函数后，调用者会建立自己与Rendez的关系，后续调用会跳过Mgr</span></span><br><span class="line">  <span class="function">RemoteRendezvous* <span class="title">Find</span><span class="params">(int64 step_id)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Finds the local rendezvous instance for the "step_id".  Runs</span></span><br><span class="line">  <span class="comment">// "done" when the tensor for "key" is produced or an error occurs.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// This method is used by the rpc handler of RecvTensor.</span></span><br><span class="line">  <span class="comment">// 利用step_id来FindOrCreate来寻找rendez</span></span><br><span class="line">  <span class="comment">// 利用std::placeholders和std::bind来创建一个Lambda函数</span></span><br><span class="line">  <span class="comment">// 匿名函数: done_cb(std::move(done), _1, _2, _3, _4, _5)</span></span><br><span class="line">  <span class="comment">// 调用rendez的RecvLocalAsync，rendez为BaseRemoteRendezvous基类指针，但是Rdma未重写RecvLocalAsync，所以调用下文的函数</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">RecvLocalAsync</span><span class="params">(int64 step_id, <span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                      Rendezvous::DoneCallback done)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Synchronous wrapper for RecvLocalAsync.</span></span><br><span class="line">  <span class="comment">// 对前一个函数通过WaitForNotification的方式进行同步管理</span></span><br><span class="line">  <span class="function">Status <span class="title">RecvLocal</span><span class="params">(int64 step_id, <span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span></span></span><br><span class="line"><span class="function"><span class="params">                   Tensor* val, <span class="keyword">bool</span>* is_dead)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Removes rendezvous for "step_id".</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// TODO(zhifengc): Have a background thread in worker that</span></span><br><span class="line">  <span class="comment">// periodically calls CleanupAll().</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">Cleanup</span><span class="params">(int64 step_id)</span> override</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Removed all rendezvous.</span></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">CleanupAll</span><span class="params">()</span> override</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="function"><span class="keyword">virtual</span> BaseRemoteRendezvous* <span class="title">Create</span><span class="params">(int64 step_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                                       <span class="keyword">const</span> WorkerEnv* worker_env)</span> </span>= <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  <span class="comment">// Maps step_id to rendezvous.</span></span><br><span class="line">  <span class="keyword">typedef</span> gtl::FlatMap&lt;int64, BaseRemoteRendezvous*&gt; Table;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Not owned.</span></span><br><span class="line">  <span class="keyword">const</span> WorkerEnv* <span class="keyword">const</span> worker_env_;</span><br><span class="line"></span><br><span class="line">  mutex mu_;</span><br><span class="line">  <span class="function">Table table_ <span class="title">GUARDED_BY</span><span class="params">(mu_)</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 根据step_id在Table中查找或者创建一个新的，并返回这个Rendezevous，创建时调用Create纯虚函数(继承类实现之)</span></span><br><span class="line">  <span class="function">BaseRemoteRendezvous* <span class="title">FindOrCreate</span><span class="params">(int64 step_id)</span></span>;</span><br><span class="line"></span><br><span class="line">  TF_DISALLOW_COPY_AND_ASSIGN(BaseRendezvousMgr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>BaseRendezvousMgr的子类RdmaRendezvousMgr</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// RendezvousMgr keeps track of a set of local rendezvous instances.</span></span><br><span class="line"><span class="comment">// All tensors sent by this worker are buffered in a RendezvousMgr</span></span><br><span class="line"><span class="comment">// until the tensor is received.  Each global unique "step_id"</span></span><br><span class="line"><span class="comment">// corresponds to one local rendezvous instance managed by a</span></span><br><span class="line"><span class="comment">// RendezvousMgr.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// E.g.,</span></span><br><span class="line"><span class="comment">//   Rendezvous* rendez = worker_env-&gt;rendezvous_mgr-&gt;Find(0x8935);</span></span><br><span class="line"><span class="comment">//   fork execution of an graph executor using "rendez"  on thread 1;</span></span><br><span class="line"><span class="comment">//   fork execution of another graph executor using "rendez" on thread 2;</span></span><br><span class="line"><span class="comment">//   ...</span></span><br><span class="line"><span class="comment">//   join threads 1 and 2;</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// In the example above, execution in thread 1 and 2 communicates with</span></span><br><span class="line"><span class="comment">// each other by send/recv operations through the "rend".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Tensors sent and recved through rendezvous managed by this</span></span><br><span class="line"><span class="comment">// RendezvousMgr must have keys generated by Rendezvous::CreateKey.</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">RdmaRendezvousMgr</span> :</span> <span class="keyword">public</span> BaseRendezvousMgr &#123;</span><br><span class="line"> <span class="keyword">public</span>:</span><br><span class="line">  <span class="function"><span class="keyword">explicit</span> <span class="title">RdmaRendezvousMgr</span><span class="params">(<span class="keyword">const</span> WorkerEnv* env)</span></span>;</span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">SetRdmaMgr</span><span class="params">(RdmaMgr* rdma_mgr)</span> </span>&#123; rdma_mgr_ = rdma_mgr; &#125;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">protected</span>:</span><br><span class="line">  <span class="comment">// 子类实现 返回创建的RdmaRemoteRendezvous对象，该对象将被放入BaseRendezvousMgr的Table中</span></span><br><span class="line">  <span class="function">BaseRemoteRendezvous* <span class="title">Create</span><span class="params">(int64 step_id,</span></span></span><br><span class="line"><span class="function"><span class="params">                               <span class="keyword">const</span> WorkerEnv* worker_env)</span> override</span>;</span><br><span class="line"></span><br><span class="line"> <span class="keyword">private</span>:</span><br><span class="line">  RdmaMgr* rdma_mgr_;</span><br><span class="line">  TF_DISALLOW_COPY_AND_ASSIGN(RdmaRendezvousMgr);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="发送"><a href="#发送" class="headerlink" title="发送"></a>发送</h3><p>注：GraphMgr类中的ExecuteAsync函数进行Rendezvous的Init操作。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> GraphMgr::ExecuteAsync(<span class="keyword">const</span> <span class="built_in">string</span>&amp; handle, <span class="keyword">const</span> int64 step_id,...)</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  RemoteRendezvous* rendezvous = worker_env_-&gt;rendezvous_mgr-&gt;Find(step_id);</span><br><span class="line">  Status s = rendezvous-&gt;Initialize(session);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>应用层先寻找Rendezvous</p>
<p>/tensorflow/core/distributed_runtime/graph_mgr.cc:418</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">Status GraphMgr::SendInputs(<span class="keyword">const</span> int64 step_id, <span class="keyword">const</span> NamedTensors&amp; in) &#123;</span><br><span class="line">  Rendezvous* rendezvous = worker_env_-&gt;rendezvous_mgr-&gt;Find(step_id);</span><br><span class="line">  Status s = SendInputsToRendezvous(rendezvous, in);</span><br><span class="line">  rendezvous-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status GraphMgr::SendInputsToRendezvous(Rendezvous* rendezvous,</span><br><span class="line">                                        <span class="keyword">const</span> NamedTensors&amp; in) &#123;</span><br><span class="line">  Rendezvous::ParsedKey parsed;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">const</span> <span class="keyword">auto</span>&amp; p : in) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; key = p.first;</span><br><span class="line">    <span class="keyword">const</span> Tensor&amp; val = p.second;</span><br><span class="line"></span><br><span class="line">    Status s = Rendezvous::ParseKey(key, &amp;parsed);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = rendezvous-&gt;Send(parsed, Rendezvous::Args(), val, <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Rendezvous.send为纯虚函数，实现为BaseRemoteRendezvous::Send。Rdma中没有重写。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The caller is a tensor producer and it sends a message (a tensor</span></span><br><span class="line"><span class="comment">// "val" and a bool "is_dead") under the given "key".</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// &#123;val, is_dead&#125; is bundled as a message sent and received.</span></span><br><span class="line"><span class="comment">// Typically, is_dead is set by some control flow nodes</span></span><br><span class="line"><span class="comment">// (e.g., a not-taken branch).  args is passed by Send to the</span></span><br><span class="line"><span class="comment">// Recv function to communicate any information that the Recv</span></span><br><span class="line"><span class="comment">// function might need.  This is typically only necessary for</span></span><br><span class="line"><span class="comment">// Send/Recv on the same worker.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// Send() never blocks.</span></span><br><span class="line"><span class="keyword">virtual</span> Status Rendezvous::Send(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; args, <span class="keyword">const</span> Tensor&amp; val, <span class="keyword">const</span> <span class="keyword">bool</span> is_dead) = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">Status BaseRemoteRendezvous::Send(<span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span><br><span class="line">                                  <span class="keyword">const</span> Rendezvous::Args&amp; args,</span><br><span class="line">                                  <span class="keyword">const</span> Tensor&amp; val, <span class="keyword">const</span> <span class="keyword">bool</span> is_dead) &#123;</span><br><span class="line">  VLOG(<span class="number">1</span>) &lt;&lt; <span class="string">"BaseRemoteRendezvous Send "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; parsed.FullKey();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">mutex_lock <span class="title">l</span><span class="params">(mu_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!status_.ok()) <span class="keyword">return</span> status_;</span><br><span class="line">    DCHECK(is_initialized_locked());</span><br><span class="line">    <span class="keyword">if</span> (!IsLocalDevice(session_-&gt;worker_name, parsed.src_device)) &#123;</span><br><span class="line">      <span class="keyword">return</span> errors::InvalidArgument(</span><br><span class="line">          <span class="string">"Invalid rendezvous key (src): "</span>, parsed.FullKey(), <span class="string">" @ "</span>,</span><br><span class="line">          session_-&gt;worker_name);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Buffers "val" and "device_context" in local_.</span></span><br><span class="line">  <span class="keyword">return</span> local_-&gt;Send(parsed, args, val, is_dead);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 通用Send函数</span></span><br><span class="line">Status LocalRendezvousImpl::Send(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; send_args, <span class="keyword">const</span> Tensor&amp; val,<span class="keyword">const</span> <span class="keyword">bool</span> is_dead) override &#123;</span><br><span class="line">  DoneCallback waiter = <span class="literal">nullptr</span>; <span class="comment">// 接收者的回调函数</span></span><br><span class="line">  Args recv_args;</span><br><span class="line">  uint64 key_hash = KeyHash(key.FullKey()); <span class="comment">// key_hash唯一标识tensor</span></span><br><span class="line">  VLOG(<span class="number">2</span>) &lt;&lt; <span class="string">"Send "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; key_hash &lt;&lt; <span class="string">" "</span> &lt;&lt; key.FullKey();</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">mutex_lock <span class="title">l</span><span class="params">(mu_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!status_.ok()) &#123;</span><br><span class="line">      <span class="keyword">return</span> status_;</span><br><span class="line">    &#125;</span><br><span class="line">    Item* item = <span class="literal">nullptr</span>;</span><br><span class="line">    Table::iterator iter = table_.find(key_hash); <span class="comment">// 在本地table中寻找指定tensor，若有，说明已有接收者在等待，若无，说明无接收者</span></span><br><span class="line">    <span class="keyword">if</span> (iter == table_.end()) &#123;</span><br><span class="line">      <span class="comment">// There is no waiter for this message. Insert the message</span></span><br><span class="line">      <span class="comment">// into the waiters table. The waiter will pick it up when</span></span><br><span class="line">      <span class="comment">// arrives.</span></span><br><span class="line">      <span class="comment">// 将Item放入数据后存入Table中，结束Send操作。</span></span><br><span class="line">      item = <span class="keyword">new</span> Item;</span><br><span class="line">      item-&gt;waiter = <span class="literal">nullptr</span>;</span><br><span class="line">      item-&gt;value = val;</span><br><span class="line">      item-&gt;is_dead = is_dead;</span><br><span class="line">      <span class="keyword">if</span> (send_args.device_context) &#123;</span><br><span class="line">        send_args.device_context-&gt;Ref();</span><br><span class="line">        item-&gt;send_dev_context = send_args.device_context;</span><br><span class="line">      &#125;</span><br><span class="line">      item-&gt;recv_dev_context = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The allocator attributes of item-&gt;value.</span></span><br><span class="line">      item-&gt;send_alloc_attrs = send_args.alloc_attrs;</span><br><span class="line"></span><br><span class="line">      CHECK(table_.insert(&#123;key_hash, item&#125;).second);</span><br><span class="line">      <span class="keyword">return</span> Status::OK();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      item = iter-&gt;second;</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (item-&gt;waiter == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">        <span class="comment">// There is already a message in the table under the key.</span></span><br><span class="line">        <span class="comment">// Should not happen unless it has a waiter.</span></span><br><span class="line">        <span class="keyword">return</span> errors::Aborted(<span class="string">"Duplicated send: "</span>, key.FullKey());</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="comment">// Mark item as complete.</span></span><br><span class="line">      item-&gt;has_been_recvd = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">      <span class="comment">// Get item-&gt;waiter function into waiter and set item-&gt;waiter to null</span></span><br><span class="line">      <span class="built_in">std</span>::swap(item-&gt;waiter, waiter);</span><br><span class="line">      DCHECK(item-&gt;waiter == <span class="literal">nullptr</span>);</span><br><span class="line">      DCHECK(waiter != <span class="literal">nullptr</span>);</span><br><span class="line"></span><br><span class="line">      <span class="comment">// The ref on recv_dev_context transfers below.</span></span><br><span class="line">      recv_args.device_context = item-&gt;recv_dev_context;</span><br><span class="line">      recv_args.alloc_attrs = item-&gt;recv_alloc_attrs;</span><br><span class="line">      item-&gt;recv_dev_context = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="keyword">if</span> (tolerate_dup_recv_) &#123;</span><br><span class="line">        item-&gt;value = val;</span><br><span class="line">        item-&gt;is_dead = is_dead;</span><br><span class="line">        <span class="keyword">if</span> (send_args.device_context) &#123;</span><br><span class="line">          send_args.device_context-&gt;Ref();</span><br><span class="line">          item-&gt;send_dev_context = send_args.device_context;</span><br><span class="line">        &#125;</span><br><span class="line">        item-&gt;send_alloc_attrs = send_args.alloc_attrs;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;  <span class="comment">// mutex</span></span><br><span class="line">  <span class="comment">// Notify the waiter by invoking its done closure, outside scope</span></span><br><span class="line">  <span class="comment">// of the table lock.</span></span><br><span class="line">  <span class="comment">// 直接运行接收者的回调函数，回调函数中进行数据传输操作</span></span><br><span class="line">  waiter(Status::OK(), send_args, recv_args, val, is_dead);</span><br><span class="line">  <span class="keyword">if</span> (recv_args.device_context) recv_args.device_context-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="接收"><a href="#接收" class="headerlink" title="接收"></a>接收</h3><p>应用层先寻找Rendezvous</p>
<p>/tensorflow/core/distributed_runtime/graph_mgr.cc:425</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 阻塞等待式接收</span></span><br><span class="line">Status GraphMgr::RecvOutputs(<span class="keyword">const</span> int64 step_id, NamedTensors* out) &#123;</span><br><span class="line">  Rendezvous* rendezvous = worker_env_-&gt;rendezvous_mgr-&gt;Find(step_id);</span><br><span class="line">  Status s = RecvOutputsFromRendezvous(rendezvous, out);</span><br><span class="line">  rendezvous-&gt;Unref();</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status GraphMgr::RecvOutputsFromRendezvous(Rendezvous* rendezvous,</span><br><span class="line">                                           NamedTensors* out) &#123;</span><br><span class="line">  <span class="comment">// Receives values requested by the caller.</span></span><br><span class="line">  Rendezvous::ParsedKey parsed;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : *out) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; key = p.first;</span><br><span class="line">    Tensor* val = &amp;p.second;</span><br><span class="line">    <span class="keyword">bool</span> is_dead = <span class="literal">false</span>;</span><br><span class="line">    Status s = Rendezvous::ParseKey(key, &amp;parsed);</span><br><span class="line">    <span class="keyword">if</span> (s.ok()) &#123;</span><br><span class="line">      s = rendezvous-&gt;Recv(parsed, Rendezvous::Args(), val, &amp;is_dead);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_dead) &#123;</span><br><span class="line">      s = errors::InvalidArgument(<span class="string">"The tensor returned for "</span>, key,</span><br><span class="line">                                  <span class="string">" was not valid."</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) <span class="keyword">return</span> s;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> Status::OK();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Status Rendezvous::Recv(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; recv_args,</span><br><span class="line">                        Tensor* val, <span class="keyword">bool</span>* is_dead, int64 timeout_ms) &#123;</span><br><span class="line">  Status ret;</span><br><span class="line">  Notification n;</span><br><span class="line">  RecvAsync(key, recv_args,</span><br><span class="line">            [&amp;ret, &amp;n, val, is_dead](<span class="keyword">const</span> Status&amp; s, <span class="keyword">const</span> Args&amp; send_args,</span><br><span class="line">                                     <span class="keyword">const</span> Args&amp; recv_args, <span class="keyword">const</span> Tensor&amp; v,</span><br><span class="line">                                     <span class="keyword">const</span> <span class="keyword">bool</span> dead) &#123;</span><br><span class="line">              ret = s;</span><br><span class="line">              *val = v;</span><br><span class="line">              *is_dead = dead;</span><br><span class="line">              n.Notify();</span><br><span class="line">            &#125;);</span><br><span class="line">  <span class="keyword">if</span> (timeout_ms &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    int64 timeout_us = timeout_ms * <span class="number">1000</span>;</span><br><span class="line">    <span class="keyword">bool</span> notified = WaitForNotificationWithTimeout(&amp;n, timeout_us);</span><br><span class="line">    <span class="keyword">if</span> (!notified) &#123;</span><br><span class="line">      <span class="keyword">return</span> Status(error::DEADLINE_EXCEEDED,</span><br><span class="line">                    <span class="string">"Timed out waiting for notification"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    n.WaitForNotification();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 提供Callback的异步接收(RDMA重写此部分)</span></span><br><span class="line"><span class="keyword">void</span> GraphMgr::RecvOutputsAsync(<span class="keyword">const</span> int64 step_id, NamedTensors* out,</span><br><span class="line">                                StatusCallback done) &#123;</span><br><span class="line">  Rendezvous* rendezvous = worker_env_-&gt;rendezvous_mgr-&gt;Find(step_id);</span><br><span class="line">  RecvOutputsFromRendezvousAsync(rendezvous, out,</span><br><span class="line">                                 [done, rendezvous](<span class="keyword">const</span> Status s) &#123;</span><br><span class="line">                                   rendezvous-&gt;Unref();</span><br><span class="line">                                   done(s);</span><br><span class="line">                                 &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> GraphMgr::RecvOutputsFromRendezvousAsync(Rendezvous* rendezvous,</span><br><span class="line">                                              NamedTensors* out,</span><br><span class="line">                                              <span class="keyword">const</span> StatusCallback&amp; done) &#123;</span><br><span class="line">  <span class="keyword">if</span> (out-&gt;empty()) &#123;</span><br><span class="line">    done(Status::OK());</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// We compute the args before calling RecvAsync because we need to ensure that</span></span><br><span class="line">  <span class="comment">// out isn't being iterated over after done is called, since done deletes out.</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">std</span>::tuple&lt;<span class="built_in">string</span>, Tensor*, Rendezvous::ParsedKey&gt;&gt; args;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : *out) &#123;</span><br><span class="line">    Rendezvous::ParsedKey parsed;</span><br><span class="line">    Status s = Rendezvous::ParseKey(p.first, &amp;parsed);</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      done(s);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    args.push_back(<span class="built_in">std</span>::make_tuple(p.first, &amp;p.second, parsed));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    mutex mu;</span><br><span class="line">    <span class="keyword">int</span> done_counter;</span><br><span class="line">    Status shared_status = Status::OK();</span><br><span class="line">  &#125; CallState;</span><br><span class="line">  CallState* call_state = <span class="keyword">new</span> CallState;</span><br><span class="line">  call_state-&gt;done_counter = out-&gt;size();</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; p : args) &#123;</span><br><span class="line">    <span class="keyword">const</span> <span class="built_in">string</span>&amp; key = <span class="built_in">std</span>::get&lt;<span class="number">0</span>&gt;(p);</span><br><span class="line">    Tensor* val = <span class="built_in">std</span>::get&lt;<span class="number">1</span>&gt;(p);</span><br><span class="line">    Rendezvous::ParsedKey parsed = <span class="built_in">std</span>::get&lt;<span class="number">2</span>&gt;(p);</span><br><span class="line">    rendezvous-&gt;RecvAsync(</span><br><span class="line">        parsed, Rendezvous::Args(),</span><br><span class="line">        [val, done, key, call_state](<span class="keyword">const</span> Status&amp; s,</span><br><span class="line">                                     <span class="keyword">const</span> Rendezvous::Args&amp; send_args,</span><br><span class="line">                                     <span class="keyword">const</span> Rendezvous::Args&amp; recv_args,</span><br><span class="line">                                     <span class="keyword">const</span> Tensor&amp; v, <span class="keyword">const</span> <span class="keyword">bool</span> is_dead) &#123;</span><br><span class="line">          Status status = s;</span><br><span class="line">          <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">            *val = v;</span><br><span class="line">            <span class="keyword">if</span> (is_dead) &#123;</span><br><span class="line">              status = errors::InvalidArgument(<span class="string">"The tensor returned for "</span>, key,</span><br><span class="line">                                               <span class="string">" was not valid."</span>);</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          call_state-&gt;mu.lock();</span><br><span class="line">          call_state-&gt;shared_status.Update(status);</span><br><span class="line">          call_state-&gt;done_counter--;</span><br><span class="line">          <span class="comment">// If we are the last async call to return, call the done callback.</span></span><br><span class="line">          <span class="keyword">if</span> (call_state-&gt;done_counter == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">const</span> Status&amp; final_status = call_state-&gt;shared_status;</span><br><span class="line">            call_state-&gt;mu.unlock();</span><br><span class="line">            done(final_status);</span><br><span class="line">            <span class="keyword">delete</span> call_state;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          call_state-&gt;mu.unlock();</span><br><span class="line">        &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>RdmaRemoteRendezvous中没有重写RecvAsync，故调用基类的RecvAsync函数</p>
<p>不管是阻塞式接收还是Callback式接收，都调用以下函数。阻塞式接收的Callback函数自动生成为notify函数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// This method is called only by the RecvOp.  It tests to see</span></span><br><span class="line"><span class="comment">// whether the value will be produced by a local or remote device</span></span><br><span class="line"><span class="comment">// and handles accordingly.  In the local case it forwards to</span></span><br><span class="line"><span class="comment">// local_, in the remote case it initiates an RPC request.</span></span><br><span class="line"><span class="keyword">void</span> BaseRemoteRendezvous::RecvAsync(<span class="keyword">const</span> ParsedKey&amp; parsed,</span><br><span class="line">                                     <span class="keyword">const</span> Rendezvous::Args&amp; recv_args,</span><br><span class="line">                                     DoneCallback done) &#123;</span><br><span class="line">  VLOG(<span class="number">1</span>) &lt;&lt; <span class="string">"RemoteRendezvous Recv "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; parsed.FullKey();</span><br><span class="line">  CHECK(is_initialized()) &lt;&lt; <span class="string">"RecvAsync called when uninitialized."</span>;</span><br><span class="line">  Status s = ValidateDevices(parsed, <span class="literal">false</span> <span class="comment">/*!is_src*/</span>);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    done(s, Args(), recv_args, Tensor(), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Are src and dst in the same worker?</span></span><br><span class="line">  <span class="keyword">if</span> (IsSameWorker(parsed.src, parsed.dst)) &#123;</span><br><span class="line">    <span class="comment">// Recv the tensor from local_.</span></span><br><span class="line">    local_-&gt;RecvAsync(</span><br><span class="line">        parsed, recv_args,</span><br><span class="line">        [<span class="keyword">this</span>, parsed, done](</span><br><span class="line">            <span class="keyword">const</span> Status&amp; status, <span class="keyword">const</span> Rendezvous::Args&amp; send_args,</span><br><span class="line">            <span class="keyword">const</span> Rendezvous::Args&amp; recv_args, <span class="keyword">const</span> Tensor&amp; in, <span class="keyword">bool</span> is_dead) &#123;</span><br><span class="line">          Tensor* out = <span class="keyword">new</span> Tensor;</span><br><span class="line">          StatusCallback final_callback = [done, send_args, recv_args, out,</span><br><span class="line">                                           is_dead](<span class="keyword">const</span> Status&amp; s) &#123;</span><br><span class="line">            done(s, send_args, recv_args, *out, is_dead);</span><br><span class="line">            <span class="keyword">delete</span> out;</span><br><span class="line">          &#125;;</span><br><span class="line"></span><br><span class="line">          <span class="keyword">if</span> (status.ok()) &#123;</span><br><span class="line">            SameWorkerRecvDone(parsed, send_args, recv_args, in, out,</span><br><span class="line">                               <span class="built_in">std</span>::move(final_callback));</span><br><span class="line">          &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            final_callback(status);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    RecvFromRemoteAsync(parsed, recv_args, <span class="built_in">std</span>::move(done));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>若是本地操作，调用LocalRendezvousImpl类的RecvAsync。</p>
<p>若是远程操作，调用RDMA中的重写部分。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> RdmaRemoteRendezvous::RecvFromRemoteAsync(</span><br><span class="line">    <span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed, <span class="keyword">const</span> Rendezvous::Args&amp; recv_args,</span><br><span class="line">    DoneCallback done) &#123;</span><br><span class="line">  Status s;</span><br><span class="line">  <span class="comment">// parse src_name and dst_name</span></span><br><span class="line">  <span class="built_in">string</span> src_name, dst_name, unused;</span><br><span class="line">  <span class="keyword">if</span> (!DeviceNameUtils::SplitDeviceName(parsed.src_device, &amp;src_name,</span><br><span class="line">                                        &amp;unused)) &#123;</span><br><span class="line">    s = errors::Internal(<span class="string">"Could not parse src name."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(s.ok()) &lt;&lt; <span class="string">"s is not ok, error code "</span> &lt;&lt; s.error_message();</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    done(s, Args(), recv_args, Tensor&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (!DeviceNameUtils::SplitDeviceName(parsed.dst_device, &amp;dst_name,</span><br><span class="line">                                        &amp;unused)) &#123;</span><br><span class="line">    s = errors::Internal(<span class="string">"Could not parse dst name."</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(s.ok()) &lt;&lt; <span class="string">"s is not ok, error code "</span> &lt;&lt; s.error_message();</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    done(s, Args(), recv_args, Tensor&#123;&#125;, <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(dst_name.compare(rdma_mgr_-&gt;local_worker()) == <span class="number">0</span>);</span><br><span class="line">  RdmaChannel* rc = rdma_mgr_-&gt;FindChannel(src_name);</span><br><span class="line">  string key(std::move(parsed.FullKey().ToString()));</span><br><span class="line">  <span class="built_in">string</span> key_with_step_id = VerbsUtil::AppendStepidToKey(key, step_id_);</span><br><span class="line">  <span class="comment">// insert callback</span></span><br><span class="line">  rc-&gt;InsertRecvCallback(key_with_step_id, [<span class="keyword">this</span>, key, key_with_step_id, rc,</span><br><span class="line">                                            recv_args, parsed, done]() &#123;</span><br><span class="line">    Status s;</span><br><span class="line">    Device* src_dev;</span><br><span class="line">    s = env_-&gt;device_mgr-&gt;LookupDevice(<span class="string">"CPU:0"</span>, &amp;src_dev);</span><br><span class="line">    CHECK(s.ok()) &lt;&lt; <span class="string">"s is not ok, error code "</span> &lt;&lt; s.error_message();</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      done(s, Args(), recv_args, Tensor(), <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Device* dst_dev;</span><br><span class="line">    s = env_-&gt;device_mgr-&gt;LookupDevice(parsed.dst_device, &amp;dst_dev);</span><br><span class="line">    CHECK(s.ok()) &lt;&lt; <span class="string">"s is not ok, error code "</span> &lt;&lt; s.error_message();</span><br><span class="line">    <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">      done(s, Args(), recv_args, Tensor(), <span class="literal">true</span>);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    RdmaBuffer* rb = rc-&gt;FindBuffer(key);</span><br><span class="line">    RdmaMessage rm;</span><br><span class="line">    CHECK(rb-&gt;size_ &gt;= RdmaMessage::kMessageTotalBytes);</span><br><span class="line">    RdmaMessage::ParseMessage(rm, rb-&gt;buffer_);</span><br><span class="line">    CHECK(rm.type_ == RDMA_MESSAGE_TENSOR_WRITE);</span><br><span class="line">    Tensor val;</span><br><span class="line">    <span class="keyword">if</span> (!rm.is_dead_) &#123;</span><br><span class="line">      <span class="keyword">void</span>* input = <span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(rb-&gt;buffer_) +</span><br><span class="line">                    RdmaMessage::kTensorBufferStartIndex;</span><br><span class="line">      <span class="comment">// 反向解析proto</span></span><br><span class="line">      TensorProto proto;</span><br><span class="line">      CHECK(rm.tensor_bytes_ + RdmaMessage::kTensorBufferStartIndex &lt;=</span><br><span class="line">            rb-&gt;size_);</span><br><span class="line">      CHECK(ParseProtoUnlimited(&amp;proto, input, rm.tensor_bytes_))</span><br><span class="line">          &lt;&lt; <span class="string">"fail to parse proto from array"</span>;</span><br><span class="line">      s = dst_dev-&gt;MakeTensorFromProto(proto, recv_args.alloc_attrs, &amp;val);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    rc-&gt;RemoveRecvCallback(key_with_step_id);</span><br><span class="line">    <span class="comment">// create message</span></span><br><span class="line">    RdmaMessage br;</span><br><span class="line">    br.type_ = RDMA_MESSAGE_BUFFER_IDLE;</span><br><span class="line">    br.name_size_ = key.size();</span><br><span class="line">    br.name_ = key;</span><br><span class="line">    <span class="built_in">string</span> message = RdmaMessage::CreateMessage(br);</span><br><span class="line">    RdmaBuffer* tb = rc-&gt;tx_message_buffer_;</span><br><span class="line">    tb-&gt;EnqueueItem(message);</span><br><span class="line">    tb-&gt;SendNextItem();</span><br><span class="line">    done(s, Args(), recv_args, val, rm.is_dead_);</span><br><span class="line">  &#125;);</span><br><span class="line">  <span class="comment">// append key to message queue</span></span><br><span class="line">  <span class="comment">// 将Callback放入Channel后，发送TENSOR_REQUEST消息。</span></span><br><span class="line">  RdmaBuffer* rb = rc-&gt;tx_message_buffer_;</span><br><span class="line">  RdmaMessage rm;</span><br><span class="line">  rm.type_ = RDMA_MESSAGE_TENSOR_REQUEST;</span><br><span class="line">  rm.name_size_ = key.size();</span><br><span class="line">  rm.name_ = key; <span class="comment">// key为tensor buffer名称</span></span><br><span class="line">  rm.step_id_ = step_id_; <span class="comment">//标识tensor</span></span><br><span class="line">  <span class="built_in">string</span> message = RdmaMessage::CreateMessage(rm);</span><br><span class="line">  rb-&gt;EnqueueItem(message);</span><br><span class="line">  rb-&gt;SendNextItem();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">// Send the next tensor from the buffer's job queue.</span></span><br><span class="line"><span class="keyword">void</span> RdmaTensorBuffer::SendNextItem() &#123;</span><br><span class="line">  <span class="comment">// get the key</span></span><br><span class="line">  <span class="built_in">string</span> key_with_step_id = <span class="string">""</span>;</span><br><span class="line">  &#123;</span><br><span class="line">    mutex_lock lock&#123;mu_&#125;;</span><br><span class="line">    <span class="keyword">if</span> (!queue_.empty()) &#123;</span><br><span class="line">      key_with_step_id = queue_.front();</span><br><span class="line">      queue_.pop();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// send the tensor if a key is acquired.</span></span><br><span class="line">  <span class="keyword">if</span> (key_with_step_id != <span class="string">""</span>) &#123;</span><br><span class="line">    VLOG(<span class="number">2</span>) &lt;&lt; <span class="string">"try to send tensor: "</span> &lt;&lt; key_with_step_id;</span><br><span class="line">    <span class="built_in">string</span> key;</span><br><span class="line">    int64 step_id;</span><br><span class="line">    VerbsUtil::GetKeyAndStepId(key_with_step_id, key, step_id);</span><br><span class="line">    CHECK(key.compare(name_) == <span class="number">0</span>);</span><br><span class="line">    Rendezvous::ParsedKey parsed;</span><br><span class="line">    Rendezvous::ParseKey(key, &amp;parsed);</span><br><span class="line">    Rendezvous::DoneCallback cb = [<span class="keyword">this</span>, key_with_step_id, key, step_id,</span><br><span class="line">                                   parsed](<span class="keyword">const</span> Status&amp; status,</span><br><span class="line">                                           <span class="keyword">const</span> Rendezvous::Args&amp; send_args,</span><br><span class="line">                                           <span class="keyword">const</span> Rendezvous::Args&amp; recv_args,</span><br><span class="line">                                           <span class="keyword">const</span> Tensor&amp; in, <span class="keyword">bool</span> is_dead) &#123;</span><br><span class="line">      CHECK(status.ok()) &lt;&lt; <span class="string">"RecvLocalAsync was not ok, key"</span> &lt;&lt; key_with_step_id</span><br><span class="line">                         &lt;&lt; <span class="string">" error message: "</span> &lt;&lt; status.error_message();</span><br><span class="line">      <span class="keyword">size_t</span> buffer_size = RdmaMessage::kMessageTotalBytes;</span><br><span class="line">      <span class="keyword">size_t</span> tensor_bytes = <span class="number">0</span>;</span><br><span class="line">      TensorProto proto;</span><br><span class="line">      <span class="comment">// Figures out which device the tensor is hosted on.</span></span><br><span class="line">      Device* src_dev = <span class="literal">nullptr</span>;</span><br><span class="line">      Status s = channel_-&gt;adapter_-&gt;worker_env_-&gt;device_mgr-&gt;LookupDevice(</span><br><span class="line">          parsed.src_device, &amp;src_dev);</span><br><span class="line">      CHECK(s.ok()) &lt;&lt; <span class="string">"src device not found"</span>;</span><br><span class="line">      <span class="comment">// Does the device have the right incarnation number we expect?</span></span><br><span class="line">      CHECK(src_dev-&gt;attributes().incarnation() == parsed.src_incarnation)</span><br><span class="line">          &lt;&lt; <span class="string">"RecvTensor expects a different device incarnation: "</span></span><br><span class="line">          &lt;&lt; parsed.src_incarnation &lt;&lt; <span class="string">" vs. "</span></span><br><span class="line">          &lt;&lt; src_dev-&gt;attributes().incarnation()</span><br><span class="line">          &lt;&lt; <span class="string">". Your worker job was probably restarted. Check your "</span></span><br><span class="line">          &lt;&lt; <span class="string">"worker job for the reason why it was restarted."</span>;</span><br><span class="line">      Device* dst_dev = <span class="literal">nullptr</span>;</span><br><span class="line">      <span class="comment">// destination is on CPU.</span></span><br><span class="line">      s = channel_-&gt;adapter_-&gt;worker_env_-&gt;device_mgr-&gt;LookupDevice(<span class="string">"CPU:0"</span>,</span><br><span class="line">                                                                    &amp;dst_dev);</span><br><span class="line">      CHECK(s.ok()) &lt;&lt; <span class="string">"dst device not found"</span>;</span><br><span class="line">      AllocatorAttributes dst_alloc_attr;</span><br><span class="line">      dst_alloc_attr.set_on_host(<span class="literal">true</span>);</span><br><span class="line">      <span class="comment">// string tensor needs to be serialized</span></span><br><span class="line">      <span class="keyword">if</span> (src_dev-&gt;tensorflow_gpu_device_info() &amp;&amp;</span><br><span class="line">          (!send_args.alloc_attrs.on_host())) &#123;</span><br><span class="line">        CHECK(send_args.device_context)</span><br><span class="line">            &lt;&lt; <span class="string">"send dev name: "</span> &lt;&lt; src_dev-&gt;name()</span><br><span class="line">            &lt;&lt; <span class="string">" gpu_info: "</span> &lt;&lt; src_dev-&gt;tensorflow_gpu_device_info();</span><br><span class="line">        <span class="comment">// "val" is on a GPU. Uses GPUUtil to fill the proto.</span></span><br><span class="line">        s = VerbsUtil::SetProtoFromGPUSync(</span><br><span class="line">            in, src_dev, send_args.device_context, &amp;proto, is_dead);</span><br><span class="line">        CHECK(s.ok()) &lt;&lt; <span class="string">"set proto from gpu sync"</span>;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// tensor is in CPU memory.</span></span><br><span class="line">        in.AsProtoTensorContent(&amp;proto);</span><br><span class="line">      &#125;</span><br><span class="line">      tensor_bytes = proto.ByteSize();</span><br><span class="line">      <span class="comment">// maybe some margin for string tensor?</span></span><br><span class="line">      buffer_size += tensor_bytes;</span><br><span class="line">      <span class="comment">// prepare message</span></span><br><span class="line">      RdmaMessage rm;</span><br><span class="line">      rm.name_size_ = key.size();</span><br><span class="line">      rm.name_ = key;</span><br><span class="line">      rm.tensor_shape_ = in.shape();</span><br><span class="line">      rm.data_type_ = in.dtype();</span><br><span class="line">      rm.step_id_ = step_id;</span><br><span class="line">      rm.is_dead_ = is_dead;</span><br><span class="line">      rm.tensor_bytes_ = tensor_bytes;</span><br><span class="line">      rm.buffer_size_ = buffer_size;</span><br><span class="line">      mu_.lock();</span><br><span class="line">      <span class="keyword">if</span> (local_status_ == none ||</span><br><span class="line">          (buffer_size &gt; size_ &amp;&amp; local_status_ == idle &amp;&amp;</span><br><span class="line">           remote_status_ == idle)) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((local_status_ != none) &amp;&amp; (buffer_size &gt; size_)) &#123;</span><br><span class="line">          CHECK(rm.data_type_ == DT_STRING)</span><br><span class="line">              &lt;&lt; <span class="string">"Only string tensor allows to change size"</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        CreateCPUBuffer(buffer_size, <span class="literal">false</span>);</span><br><span class="line">        mu_.unlock();</span><br><span class="line">        <span class="comment">// put back the key since it is not sent;</span></span><br><span class="line">        EnqueueItem(key_with_step_id);</span><br><span class="line">        <span class="comment">// ask the remote to create the same buffer</span></span><br><span class="line">        rm.type_ = RDMA_MESSAGE_BUFFER_REQUEST;</span><br><span class="line">        rm.remote_addr_ = <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">uint64_t</span>&gt;(buffer_);</span><br><span class="line">        rm.rkey_ = self_-&gt;rkey;</span><br><span class="line">        <span class="built_in">string</span> message = RdmaMessage::CreateMessage(rm);</span><br><span class="line">        channel_-&gt;tx_message_buffer_-&gt;EnqueueItem(message);</span><br><span class="line">        channel_-&gt;tx_message_buffer_-&gt;SendNextItem();</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((local_status_ == idle) &amp;&amp; (remote_status_ == idle)) &#123;</span><br><span class="line">        <span class="comment">// both buffers are ready, send the tensor</span></span><br><span class="line">        local_status_ = busy;</span><br><span class="line">        remote_status_ = busy;</span><br><span class="line">        <span class="comment">// local/remote_status_ won't be set back to idle</span></span><br><span class="line">        <span class="comment">// unitl Write() is successful</span></span><br><span class="line">        mu_.unlock();</span><br><span class="line">        CHECK((buffer_size == size_ &amp;&amp; rm.data_type_ != DT_STRING) ||</span><br><span class="line">              (buffer_size &lt;= size_ &amp;&amp; rm.data_type_ == DT_STRING))</span><br><span class="line">            &lt;&lt; <span class="string">"tensor and buffer size do not agree!"</span></span><br><span class="line">            &lt;&lt; <span class="string">" buffer_size = "</span> &lt;&lt; size_</span><br><span class="line">            &lt;&lt; <span class="string">" requested tensor size = "</span> &lt;&lt; buffer_size &lt;&lt; in.DebugString();</span><br><span class="line">        <span class="keyword">uint32_t</span> imm_data = LookupBufferIndex(key);</span><br><span class="line">        rm.type_ = RDMA_MESSAGE_TENSOR_WRITE;</span><br><span class="line">        <span class="built_in">string</span> message = RdmaMessage::CreateMessage(rm);</span><br><span class="line">        <span class="built_in">memcpy</span>(buffer_, message.data(), message.size());</span><br><span class="line">        <span class="keyword">if</span> (!is_dead) &#123;</span><br><span class="line">          <span class="comment">// copy the tensor buffer content</span></span><br><span class="line">          <span class="keyword">void</span>* output =</span><br><span class="line">              <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(<span class="keyword">static_cast</span>&lt;<span class="keyword">char</span>*&gt;(buffer_) +</span><br><span class="line">                                 RdmaMessage::kTensorBufferStartIndex);</span><br><span class="line">          CHECK(tensor_bytes + RdmaMessage::kTensorBufferStartIndex &lt;= size_);</span><br><span class="line">          proto.SerializeToArray(output, tensor_bytes);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          buffer_size = RdmaMessage::kMessageTotalBytes;</span><br><span class="line">        &#125;</span><br><span class="line">        Write(imm_data, buffer_size);</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        mu_.unlock();</span><br><span class="line">        <span class="comment">// put back the key since it is not sent;</span></span><br><span class="line">        EnqueueItem(key_with_step_id);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">    channel_-&gt;adapter_-&gt;worker_env_-&gt;rendezvous_mgr</span><br><span class="line">        -&gt;RecvLocalAsync(step_id, parsed, cb);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseRendezvousMgr::RecvLocalAsync(int64 step_id,</span><br><span class="line">                                       <span class="keyword">const</span> Rendezvous::ParsedKey&amp; parsed,</span><br><span class="line">                                       Rendezvous::DoneCallback done) &#123;</span><br><span class="line">  BaseRemoteRendezvous* rendez = FindOrCreate(step_id);</span><br><span class="line">  <span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>::placeholders;</span><br><span class="line">  Rendezvous::DoneCallback done_cb = <span class="built_in">std</span>::bind(</span><br><span class="line">      [rendez](Rendezvous::DoneCallback done,</span><br><span class="line">               <span class="comment">// Begin unbound arguments.</span></span><br><span class="line">               <span class="keyword">const</span> Status&amp; s, <span class="keyword">const</span> Rendezvous::Args&amp; send_args,</span><br><span class="line">               <span class="keyword">const</span> Rendezvous::Args&amp; recv_args, <span class="keyword">const</span> Tensor&amp; v, <span class="keyword">bool</span> dead) &#123;</span><br><span class="line">        rendez-&gt;Unref();</span><br><span class="line">        done(s, send_args, recv_args, v, dead);</span><br><span class="line">      &#125;,</span><br><span class="line">      <span class="built_in">std</span>::move(done), _1, _2, _3, _4, _5);</span><br><span class="line">  rendez-&gt;RecvLocalAsync(parsed, <span class="built_in">std</span>::move(done_cb));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseRemoteRendezvous::RecvLocalAsync(<span class="keyword">const</span> ParsedKey&amp; parsed,</span><br><span class="line">                                          DoneCallback done) &#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="function">mutex_lock <span class="title">l</span><span class="params">(mu_)</span></span>;</span><br><span class="line">    <span class="keyword">if</span> (!is_initialized_locked()) &#123;</span><br><span class="line">      <span class="comment">// RecvLocalAsync can be called (due to an incoming RecvTensor RPC from a</span></span><br><span class="line">      <span class="comment">// remote worker) before the RunStep (or PartialRunStep) RPC from the</span></span><br><span class="line">      <span class="comment">// master arrives. RecvLocalAsync thus buffers the arguments until after</span></span><br><span class="line">      <span class="comment">// the RemoteRendezvous is Initialize()'d, when it completes the</span></span><br><span class="line">      <span class="comment">// rendezvous logic. At some point after Initialize() is called, a Tensor</span></span><br><span class="line">      <span class="comment">// is produced locally that will then be sent in response to the incoming</span></span><br><span class="line">      <span class="comment">// RPC.</span></span><br><span class="line">      DeferredCall call(parsed, std::move(done));</span><br><span class="line">      deferred_calls_.push_back(call);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  RecvLocalAsyncInternal(parsed, <span class="built_in">std</span>::move(done));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> BaseRemoteRendezvous::RecvLocalAsyncInternal(<span class="keyword">const</span> ParsedKey&amp; parsed,</span><br><span class="line">                                                  DoneCallback done) &#123;</span><br><span class="line">  Status s = ValidateDevices(parsed, <span class="literal">true</span> <span class="comment">/* is_src */</span>);</span><br><span class="line">  <span class="keyword">if</span> (!s.ok()) &#123;</span><br><span class="line">    done(s, Args(), Args(), Tensor(), <span class="literal">false</span>);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  local_-&gt;RecvAsync(parsed, Args(), <span class="built_in">std</span>::move(done));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Callback provided by a tensor consumer waiting on the rendezvous.</span></span><br><span class="line"><span class="comment">// It will be invoked when the tensor is available, or when a non-OK</span></span><br><span class="line"><span class="comment">// status arises in the production of that tensor.  It also gets</span></span><br><span class="line"><span class="comment">// two Rendezvous::Args, one provided by the sender, the other by the</span></span><br><span class="line"><span class="comment">// receiver, which may be needed when a non-CPU device is in use</span></span><br><span class="line"><span class="comment">// by either side.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="built_in">std</span>::function&lt;<span class="keyword">void</span>(<span class="keyword">const</span> Status&amp;, <span class="keyword">const</span> Args&amp;, <span class="keyword">const</span> Args&amp;,</span><br><span class="line">                           <span class="keyword">const</span> Tensor&amp;, <span class="keyword">const</span> <span class="keyword">bool</span>)&gt;</span><br><span class="line">  DoneCallback;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">RecvAsync</span><span class="params">(<span class="keyword">const</span> ParsedKey&amp; key, <span class="keyword">const</span> Args&amp; recv_args,</span></span></span><br><span class="line"><span class="function"><span class="params">               DoneCallback done)</span> override </span>&#123;</span><br><span class="line">  uint64 key_hash = KeyHash(key.FullKey()); <span class="comment">// 获取tensor的hash值</span></span><br><span class="line">  VLOG(<span class="number">2</span>) &lt;&lt; <span class="string">"Recv "</span> &lt;&lt; <span class="keyword">this</span> &lt;&lt; <span class="string">" "</span> &lt;&lt; key_hash &lt;&lt; <span class="string">" "</span> &lt;&lt; key.FullKey();</span><br><span class="line">  mu_.lock();</span><br><span class="line">  <span class="keyword">if</span> (!status_.ok()) &#123;</span><br><span class="line">    <span class="comment">// Rendezvous has been aborted.</span></span><br><span class="line">    Status s = status_;</span><br><span class="line">    mu_.unlock();</span><br><span class="line">    done(s, Args(), recv_args, Tensor(), <span class="literal">false</span>); <span class="comment">// 运行回调函数，但是status为坏</span></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  Table::iterator iter = table_.find(key_hash); <span class="comment">// 在table中寻找有无接收者要的tensor</span></span><br><span class="line">  <span class="keyword">if</span> (iter != table_.end()) &#123; <span class="comment">// 若有，则</span></span><br><span class="line">    Item* item = iter-&gt;second; <span class="comment">// 得到该tensor</span></span><br><span class="line">    <span class="keyword">if</span> (item-&gt;has_been_recvd &amp;&amp; !tolerate_dup_recv_) &#123; <span class="comment">// 判断该tensor是否被读取过和是否容忍重复读取</span></span><br><span class="line">      mu_.unlock();</span><br><span class="line">      done(errors::Aborted(<span class="string">"Duplicated recv: "</span>, key.FullKey()), Args(),</span><br><span class="line">           recv_args, Tensor(), <span class="literal">false</span>);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (item-&gt;waiter == <span class="literal">nullptr</span> || tolerate_dup_recv_) &#123; <span class="comment">// 该Tensor没有接收者或者允许重复接收</span></span><br><span class="line">      <span class="comment">// A message has already arrived and is stored in the table</span></span><br><span class="line">      <span class="comment">// under this key.  Consumes the message and invokes the done</span></span><br><span class="line">      <span class="comment">// closure.</span></span><br><span class="line">      Tensor v = item-&gt;value;</span><br><span class="line">      <span class="keyword">if</span> (!tolerate_dup_recv_) &#123; <span class="comment">// 若不允许重复接收，则将table中的值清空</span></span><br><span class="line">        item-&gt;value = Tensor();</span><br><span class="line">      &#125;</span><br><span class="line">      item-&gt;has_been_recvd = <span class="literal">true</span>;</span><br><span class="line">      <span class="comment">// Before dropping the table lock, capture the item values.</span></span><br><span class="line">      <span class="comment">// DeviceContext is only non-null for non-CPU devices.</span></span><br><span class="line">      <span class="comment">// If we capture the send_dev_context, we need to hold a ref on</span></span><br><span class="line">      <span class="comment">// it.  Our caller will have a ref on the recv_dev_context,</span></span><br><span class="line">      <span class="comment">// which is not in our table.</span></span><br><span class="line">      DeviceContext* send_dev_context = item-&gt;send_dev_context;</span><br><span class="line">      <span class="keyword">if</span> (send_dev_context) send_dev_context-&gt;Ref();</span><br><span class="line">      <span class="keyword">bool</span> is_dead = item-&gt;is_dead;</span><br><span class="line">      Args send_args;</span><br><span class="line">      send_args.device_context = item-&gt;send_dev_context;</span><br><span class="line">      send_args.alloc_attrs = item-&gt;send_alloc_attrs;</span><br><span class="line">      mu_.unlock();</span><br><span class="line">      <span class="comment">// 运行回调函数</span></span><br><span class="line">      done(Status::OK(), send_args, recv_args, v, is_dead);</span><br><span class="line">      <span class="keyword">if</span> (send_dev_context) send_dev_context-&gt;Unref();</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="comment">// Already have a waiter in the waiters table under this key,</span></span><br><span class="line">      <span class="comment">// which should not happen.</span></span><br><span class="line">      mu_.unlock();</span><br><span class="line">      done(errors::Aborted(<span class="string">"Duplicated recv: "</span>, key.FullKey()), Args(),</span><br><span class="line">           recv_args, Tensor(), <span class="literal">false</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// Waiting for a message that has not arrived yet. Insert into the</span></span><br><span class="line">  <span class="comment">// waiting table. The done closure will be invoked when the</span></span><br><span class="line">  <span class="comment">// message arrives.</span></span><br><span class="line">  <span class="comment">// 若无tensor，则将hash+回调函数放入table中。</span></span><br><span class="line">  Item* item = <span class="keyword">new</span> Item;</span><br><span class="line">  item-&gt;waiter = <span class="built_in">std</span>::move(done);</span><br><span class="line">  item-&gt;recv_alloc_attrs = recv_args.alloc_attrs;</span><br><span class="line">  <span class="keyword">if</span> (recv_args.device_context) &#123;</span><br><span class="line">    item-&gt;recv_dev_context = recv_args.device_context;</span><br><span class="line">    item-&gt;recv_dev_context-&gt;Ref();</span><br><span class="line">  &#125;</span><br><span class="line">  CHECK(table_.insert(&#123;key_hash, item&#125;).second);</span><br><span class="line">  mu_.unlock();</span><br><span class="line">  <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Rdma-Write the content of the buffer</span></span><br><span class="line"><span class="keyword">void</span> RdmaBuffer::Write(<span class="keyword">uint32_t</span> imm_data, <span class="keyword">size_t</span> buffer_size) &#123;</span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_sge</span> <span class="title">list</span>;</span></span><br><span class="line">  <span class="built_in">list</span>.addr = (<span class="keyword">uint64_t</span>)buffer_;</span><br><span class="line">  <span class="built_in">list</span>.length = buffer_size;</span><br><span class="line">  <span class="built_in">list</span>.lkey = self_-&gt;lkey;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span> <span class="title">wr</span>;</span></span><br><span class="line">  <span class="built_in">memset</span>(&amp;wr, <span class="number">0</span>, <span class="keyword">sizeof</span>(wr));</span><br><span class="line">  wr.wr_id = (<span class="keyword">uint64_t</span>)<span class="keyword">this</span>;</span><br><span class="line">  wr.sg_list = &amp;<span class="built_in">list</span>;</span><br><span class="line">  wr.num_sge = <span class="number">1</span>;</span><br><span class="line">  wr.opcode = IBV_WR_RDMA_WRITE_WITH_IMM;</span><br><span class="line">  wr.send_flags = IBV_SEND_SIGNALED;</span><br><span class="line">  wr.imm_data = imm_data;</span><br><span class="line">  wr.wr.rdma.remote_addr = (<span class="keyword">uint64_t</span>)remote_.remote_addr;</span><br><span class="line">  wr.wr.rdma.rkey = remote_.rkey;</span><br><span class="line"></span><br><span class="line">  <span class="class"><span class="keyword">struct</span> <span class="title">ibv_send_wr</span>* <span class="title">bad_wr</span>;</span></span><br><span class="line">  CHECK(!ibv_post_send(channel_-&gt;qp_, &amp;wr, &amp;bad_wr)) &lt;&lt; <span class="string">"Failed to post send"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>接收详细操作：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: start</span><br><span class="line">GraphMgr_RecvOutputsAsync=&gt;subroutine: GraphMgr::RecvOutputsAsync</span><br><span class="line">(step_id, outTensor, callback1)</span><br><span class="line">GraphMgr_RecvOutputsFromRendezvousAsync=&gt;subroutine: GraphMgr::RecvOutputsFromRendezvousAsync</span><br><span class="line">(由redezvousMgr通过step_id找到的redezvous, 由callback1封装成的callback2)</span><br><span class="line">BaseRemoteRendezvous_RecvAsync=&gt;subroutine: BaseRemoteRendezvous::RecvAsync</span><br><span class="line">(parsedKey, callback2)</span><br><span class="line">BaseRemoteRendezvous_RecvAsync_Cond=&gt;condition: src == dest</span><br><span class="line">LocalRendezvousImpl_RecvAsync1=&gt;subroutine: LocalRendezvousImpl::RecvAsync</span><br><span class="line">(parsedKey, callback3(封装callback2))</span><br><span class="line">RdmaRemoteRendezvous_RecvFromRemoteAsync=&gt;subroutine: RdmaRemoteRendezvous::RecvFromRemoteAsync</span><br><span class="line">(parsedKey, callback2) | approved:&gt; www.baidu.com[blank]</span><br><span class="line">BaseRendezvousMgr_RecvLocalAsync1=&gt;subroutine: BaseRendezvousMgr::RecvLocalAsync</span><br><span class="line">(step_id, 通过key新生成的parsed, rdma callback1)</span><br><span class="line">BaseRendezvousMgr_RecvLocalAsync2=&gt;operation: 通过step_id查找BaseRemoteRendezvous</span><br><span class="line">同时将rdma callback1封装为rdma callback2</span><br><span class="line">BaseRendezvousMgr_RecvLocalAsync3=&gt;subroutine: BaseRendezvousMgr::RecvLocalAsync</span><br><span class="line">(parsed, rdma callback2)</span><br><span class="line">BaseRendezvousMgr_RecvLocalAsync4=&gt;condition: 判断该Rendezvous</span><br><span class="line">是否被init</span><br><span class="line">BaseRendezvousMgr_RecvLocalAsync4_No=&gt;operation: 将parsed和rdma callback2</span><br><span class="line">组装为DeferredCall放入对列中</span><br><span class="line">直到Rendezvous被初始化</span><br><span class="line">BaseRemoteRendezvous_RecvLocalAsyncInternal=&gt;subroutine: BaseRemoteRendezvous::RecvLocalAsyncInternal</span><br><span class="line">(parsed, rdma callback2)</span><br><span class="line">LocalRendezvousImpl_RecvAsync2=&gt;subroutine: LocalRendezvousImpl::RecvAsync</span><br><span class="line">(parsedKey, rdma callback2)</span><br><span class="line">LocalRendezvousImpl_RecvAsync=&gt;subroutine: 在Table中寻找tensor</span><br><span class="line">LocalRendezvousImpl_RecvAsync_Cond=&gt;condition: 是否找到</span><br><span class="line">LocalRendezvousImpl_RecvAsync_Cond_No=&gt;subroutine: 存储callback</span><br><span class="line">等待tensor</span><br><span class="line">LocalRendezvousImpl_RecvAsync_Cond_Yes=&gt;subroutine: 运行callback | approved:&gt; www.baidu.com[blank]</span><br><span class="line">e=&gt;end: end</span><br><span class="line"></span><br><span class="line">st-&gt;GraphMgr_RecvOutputsAsync-&gt;GraphMgr_RecvOutputsFromRendezvousAsync-&gt;BaseRemoteRendezvous_RecvAsync-&gt;BaseRemoteRendezvous_RecvAsync_Cond</span><br><span class="line">BaseRemoteRendezvous_RecvAsync_Cond(no,bottom)-&gt;RdmaRemoteRendezvous_RecvFromRemoteAsync-&gt;BaseRendezvousMgr_RecvLocalAsync1-&gt;BaseRendezvousMgr_RecvLocalAsync2-&gt;BaseRendezvousMgr_RecvLocalAsync3-&gt;BaseRendezvousMgr_RecvLocalAsync4</span><br><span class="line">BaseRendezvousMgr_RecvLocalAsync4(yes)-&gt;BaseRemoteRendezvous_RecvLocalAsyncInternal-&gt;LocalRendezvousImpl_RecvAsync2</span><br><span class="line">BaseRendezvousMgr_RecvLocalAsync4(no)-&gt;BaseRendezvousMgr_RecvLocalAsync4_No</span><br><span class="line">LocalRendezvousImpl_RecvAsync2-&gt;LocalRendezvousImpl_RecvAsync</span><br><span class="line">BaseRemoteRendezvous_RecvAsync_Cond(yes)-&gt;LocalRendezvousImpl_RecvAsync1-&gt;LocalRendezvousImpl_RecvAsync</span><br><span class="line">LocalRendezvousImpl_RecvAsync-&gt;LocalRendezvousImpl_RecvAsync_Cond</span><br><span class="line">LocalRendezvousImpl_RecvAsync_Cond(yes, left)-&gt;LocalRendezvousImpl_RecvAsync_Cond_Yes-&gt;e</span><br><span class="line">LocalRendezvousImpl_RecvAsync_Cond(no)-&gt;LocalRendezvousImpl_RecvAsync_Cond_No-&gt;e</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Title: RdmaRemoteRendezvous::RecvFromRemoteAsync</span><br><span class="line">note left of Receiver_Recv(): 将CallBack2封装成Callback3\n后放入本地Channel中</span><br><span class="line">note left of Receiver_Recv(): 将RDMA_MESSAGE_TENSOR_REQUEST\n消息放入tx_message_buffer</span><br><span class="line">Receiver_Process_CQ()-&gt;Receiver_Process_CQ(): null</span><br><span class="line">Receiver_Recv()-&gt;Sender_Process_CQ(): 发送RDMA_MESSAGE_TENSOR_REQUEST消息</span><br><span class="line">note right of Sender_Process_CQ(): 收到消息</span><br><span class="line">Sender_Process_CQ()-&gt;Receiver_Process_CQ(): 回复RDMA_MESSAGE_ACK消息</span><br><span class="line">note right of Sender_Process_CQ(): 检测本地有无该Tensor(利用key搜索)\n将(key+step_id)组合入Queue\n即将发送数据</span><br><span class="line">note right of Sender_Process_CQ(): 从Queue中获得key_with_step_id\n同时创建新的rdma callback1\n调用BaseRendezvousMgr::RecvLocalAsync\n(step_id, 通过key新生成的parsed, rdma callback1)</span><br></pre></td></tr></table></figure>
<ol>
<li>执行GraphMgr::RecvOutputsAsync，输入参数包含step_id、输出tensor和callback1。</li>
<li>执行GraphMgr::RecvOutputsFromRendezvousAsync，输入参数由step_id替换为从rendezvous_mgr找到的redezvous。函数中用callback2封装了callback1。</li>
<li>执行BaseRemoteRendezvous::RecvAsync，输入参数主要有parsed key和callback2。</li>
<li>判断src和dest。<ol>
<li>若src和dest一致，则调用LocalRendezvousImpl::RecvAsync，参数主要有parsed key和callback3(封装callback2)。</li>
<li>若不一致，调用RdmaRemoteRendezvous::RecvFromRemoteAsync。参数不变。<ol>
<li>接收方Recv函数：将CallBack2封装成Callback3后放入本地Channel中。</li>
<li>接收方Recv函数：将RDMA_MESSAGE_TENSOR_REQUEST消息放入tx_message_buffer。</li>
<li>接收方Message Buffer：发送消息。</li>
<li>发送方Process_CQ函数：收到RDMA_MESSAGE_TENSOR_REQUEST。</li>
<li>发送方Ack Buffer：回复RDMA_MESSAGE_ACK消息。</li>
<li>发送方Process_CQ函数：检测本地有无该Tensor(利用key搜索)，将(key+step_id)组合入Queue，即将发送。</li>
<li>发送方Tensor Buffer：从Queue中获得key_with_step_id，同时创建新的rdma callback1。调用BaseRendezvousMgr::RecvLocalAsync(三参数)，输入参数有step_id、通过key新生成的parsed 和 rdma callback1。</li>
<li>BaseRendezvousMgr::RecvLocalAsync(三参数)通过step_id查找BaseRemoteRendezvous，同时将rdma callback1封装为rdma callback2。调用BaseRendezvousMgr::RecvLocalAsync(二参数)。</li>
<li>BaseRendezvousMgr::RecvLocalAsync(二参数)将判断该Rendezvous是否被init，若未init，则将parsed和rdma callback2组装为DeferredCall放入对列中，直到Rendezvous被初始化。若已经INIT，则执行BaseRemoteRendezvous::RecvLocalAsyncInternal，输入参数不变(parsed和rdma callback2)。</li>
<li>调用LocalRendezvousImpl::RecvAsync，参数主要有parsed和rdma callback2。同4.1</li>
</ol>
</li>
</ol>
</li>
<li>在Table中寻找tensor。<ol>
<li>未找到，存储回调，等待tensor。</li>
<li>若找到，则运行回调。若为RDMA回调，则运行如下：<ol>
<li>将Tensor转为Proto。</li>
<li>若local和remote状态没准备好，则将(key+step_id)入队，对应4.2.7。</li>
<li>若local和remote状态就绪，但是tensor buffer空间不够。<ol>
<li>自己创建足够大的buffer。</li>
<li>将(key+step_id)入队，对应4.2.7。</li>
<li>创建RDMA_MESSAGE_BUFFER_REQUEST消息，并发送之。</li>
<li>接收方收到后回复Ack</li>
<li>…</li>
</ol>
</li>
<li>若一切就绪。<ol>
<li>创建RDMA_MESSAGE_TENSOR_WRITE消息，放入proto。</li>
<li>用IBV_WR_RDMA_WRITE_WITH_IMM写入远程信息。</li>
</ol>
</li>
</ol>
</li>
</ol>
</li>
</ol>
<h3 id="LOG"><a href="#LOG" class="headerlink" title="LOG"></a>LOG</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CHECK(condition)              \</span></span><br><span class="line">  <span class="keyword">if</span> (TF_PREDICT_FALSE(!(condition))) \</span><br><span class="line">  LOG(FATAL) &lt;&lt; <span class="string">"Check failed: "</span> <span class="meta">#condition <span class="meta-string">" "</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LOG(severity) _TF_LOG_##severity</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TF_LOG_INFO \</span></span><br><span class="line">  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, tensorflow::INFO)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TF_LOG_WARNING \</span></span><br><span class="line">  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, tensorflow::WARNING)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TF_LOG_ERROR \</span></span><br><span class="line">  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, tensorflow::ERROR)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> _TF_LOG_FATAL \</span></span><br><span class="line">  ::tensorflow::internal::LogMessageFatal(__FILE__, __LINE__)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VLOG(lvl)      \</span></span><br><span class="line">  <span class="keyword">if</span> (TF_PREDICT_FALSE(VLOG_IS_ON(lvl))) \</span><br><span class="line">  ::tensorflow::internal::LogMessage(__FILE__, __LINE__, tensorflow::INFO)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> VLOG_IS_ON(lvl) \</span></span><br><span class="line">  ((lvl) &lt;= ::tensorflow::internal::LogMessage::MinVLogLevel())</span><br><span class="line"></span><br><span class="line">int64 LogMessage::MinVLogLevel() &#123;</span><br><span class="line">  <span class="keyword">static</span> int64 min_vlog_level = MinVLogLevelFromEnv();</span><br><span class="line">  <span class="keyword">return</span> min_vlog_level;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">int64 <span class="title">MinVLogLevelFromEnv</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="keyword">char</span>* tf_env_var_val = getenv(<span class="string">"TF_CPP_MIN_VLOG_LEVEL"</span>);</span><br><span class="line">  <span class="keyword">return</span> LogLevelStrToInt(tf_env_var_val);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parse log level (int64) from environment variable (char*)</span></span><br><span class="line"><span class="function">int64 <span class="title">LogLevelStrToInt</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* tf_env_var_val)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (tf_env_var_val == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Ideally we would use env_var / safe_strto64, but it is</span></span><br><span class="line">  <span class="comment">// hard to use here without pulling in a lot of dependencies,</span></span><br><span class="line">  <span class="comment">// so we use std:istringstream instead</span></span><br><span class="line">  <span class="function"><span class="built_in">string</span> <span class="title">min_log_level</span><span class="params">(tf_env_var_val)</span></span>;</span><br><span class="line">  <span class="built_in">std</span>::<span class="function"><span class="built_in">istringstream</span> <span class="title">ss</span><span class="params">(min_log_level)</span></span>;</span><br><span class="line">  int64 level;</span><br><span class="line">  <span class="keyword">if</span> (!(ss &gt;&gt; level)) &#123;</span><br><span class="line">    <span class="comment">// Invalid vlog level setting, set level to default (0)</span></span><br><span class="line">    level = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> level;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h3><h4 id="WorkEnv"><a href="#WorkEnv" class="headerlink" title="WorkEnv"></a>WorkEnv</h4><p>/tensorflow/core/distributed_runtime/worker_env.h</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// The worker environment class, which holds a bag of pointers to</span></span><br><span class="line"><span class="comment">// per-worker singletons.</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// WorkerEnv does not own its member pointers.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">WorkerEnv</span> &#123;</span></span><br><span class="line">  Env* env = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// session_mgr encapsulates state for each session.</span></span><br><span class="line">  SessionMgr* session_mgr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// The local devices of this worker. Devices are owned by the device_mgr.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// REQUIRES: !local_devices.empty().</span></span><br><span class="line">  <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;Device*&gt; local_devices;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// device_mgr manages local devices (cpu and gpu). The WorkerService</span></span><br><span class="line">  <span class="comment">// is the network interface for managed devices.</span></span><br><span class="line">  DeviceMgr* device_mgr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A set of rendezvous keyed by step ids.</span></span><br><span class="line">  RendezvousMgrInterface* rendezvous_mgr = <span class="literal">nullptr</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// A pool of threads for scheduling compute work.</span></span><br><span class="line">  thread::ThreadPool* compute_pool = <span class="literal">nullptr</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Item"><a href="#Item" class="headerlink" title="Item"></a>Item</h4><p>/tensorflow/core/framework/rendezvous.cc</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Item</span> &#123;</span></span><br><span class="line">  DoneCallback waiter = <span class="literal">nullptr</span>;</span><br><span class="line">  Tensor value;</span><br><span class="line">  <span class="keyword">bool</span> is_dead = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">bool</span> has_been_recvd = <span class="literal">false</span>;</span><br><span class="line">  DeviceContext* send_dev_context = <span class="literal">nullptr</span>;</span><br><span class="line">  DeviceContext* recv_dev_context = <span class="literal">nullptr</span>;</span><br><span class="line">  AllocatorAttributes send_alloc_attrs;</span><br><span class="line">  AllocatorAttributes recv_alloc_attrs;</span><br><span class="line"></span><br><span class="line">  ~Item() &#123;</span><br><span class="line">    <span class="keyword">if</span> (send_dev_context) &#123;</span><br><span class="line">      send_dev_context-&gt;Unref();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (recv_dev_context) &#123;</span><br><span class="line">      recv_dev_context-&gt;Unref();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="ParseKey"><a href="#ParseKey" class="headerlink" title="ParseKey"></a>ParseKey</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Constructs a rendezvous key for the tensor of "name" sent from</span></span><br><span class="line"><span class="comment">// "src_device" to "dst_device". The tensor is generated in the frame</span></span><br><span class="line"><span class="comment">// and iteration specified by "frame_iter".</span></span><br><span class="line"><span class="comment">/*  static */</span></span><br><span class="line"><span class="built_in">string</span> Rendezvous::CreateKey(<span class="keyword">const</span> <span class="built_in">string</span>&amp; src_device, uint64 src_incarnation,</span><br><span class="line">                             <span class="keyword">const</span> <span class="built_in">string</span>&amp; dst_device, <span class="keyword">const</span> <span class="built_in">string</span>&amp; name,</span><br><span class="line">                             <span class="keyword">const</span> FrameAndIter&amp; frame_iter) &#123;</span><br><span class="line">  <span class="comment">// <span class="doctag">NOTE:</span> ';' is not used in the device name's job name.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// We include both sender and receiver in the key to facilitate</span></span><br><span class="line">  <span class="comment">// debugging. For correctness, we only need to encode the receiver.</span></span><br><span class="line">  <span class="comment">//</span></span><br><span class="line">  <span class="comment">// "src_incarnation" is used to distinguish a worker when it</span></span><br><span class="line">  <span class="comment">// restarts.</span></span><br><span class="line">  <span class="keyword">char</span> buf[strings::kFastToBufferSize];</span><br><span class="line">  <span class="keyword">return</span> strings::StrCat(</span><br><span class="line">      src_device, <span class="string">";"</span>, strings::Uint64ToHexString(src_incarnation, buf), <span class="string">";"</span>,</span><br><span class="line">      dst_device, <span class="string">";"</span>, name, <span class="string">";"</span>, frame_iter.frame_id, <span class="string">":"</span>, frame_iter.iter_id);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Parses the key constructed by CreateKey and parse src/dst device</span></span><br><span class="line"><span class="comment">// names into structures respectively.</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ParsedKey</span> &#123;</span></span><br><span class="line">  StringPiece src_device;</span><br><span class="line">  DeviceNameUtils::ParsedName src;</span><br><span class="line">  uint64 src_incarnation = <span class="number">0</span>;</span><br><span class="line">  StringPiece dst_device;</span><br><span class="line">  DeviceNameUtils::ParsedName dst;</span><br><span class="line">  StringPiece edge_name;</span><br><span class="line"></span><br><span class="line">  ParsedKey() &#123;&#125;</span><br><span class="line">  ParsedKey(<span class="keyword">const</span> ParsedKey&amp; b) &#123; *<span class="keyword">this</span> = b; &#125;</span><br><span class="line"></span><br><span class="line">  ParsedKey&amp; <span class="keyword">operator</span>=(<span class="keyword">const</span> ParsedKey&amp; b);</span><br><span class="line">  <span class="function">StringPiece <span class="title">FullKey</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> buf_; &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">private</span>:</span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">Rendezvous</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">SendOp</span>;</span></span><br><span class="line">  <span class="keyword">friend</span> <span class="class"><span class="keyword">class</span> <span class="title">RecvOp</span>;</span></span><br><span class="line">  <span class="built_in">string</span> buf_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">static</span> Status <span class="title">ParseKey</span><span class="params">(StringPiece key, ParsedKey* out)</span></span>;</span><br></pre></td></tr></table></figure>
<h3 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h3><p>10.42.10.36</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br><span class="line"><span class="keyword">import</span> tensorflow <span class="keyword">as</span> tf</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line">os.environ[<span class="string">'TF_CPP_MIN_VLOG_LEVEL'</span>] = <span class="string">'5'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Define parameters</span></span><br><span class="line">FLAGS = tf.app.flags.FLAGS</span><br><span class="line">tf.app.flags.DEFINE_float(<span class="string">'learning_rate'</span>, <span class="number">0.00003</span>, <span class="string">'Initial learning rate.'</span>)</span><br><span class="line">tf.app.flags.DEFINE_integer(<span class="string">'steps_to_validate'</span>, <span class="number">1000</span>,</span><br><span class="line">                     <span class="string">'Steps to validate and print loss'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># For distributed</span></span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">"ps_hosts"</span>, <span class="string">""</span>,</span><br><span class="line">                           <span class="string">"Comma-separated list of hostname:port pairs"</span>)</span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">"worker_hosts"</span>, <span class="string">""</span>,</span><br><span class="line">                           <span class="string">"Comma-separated list of hostname:port pairs"</span>)</span><br><span class="line">tf.app.flags.DEFINE_string(<span class="string">"job_name"</span>, <span class="string">""</span>, <span class="string">"One of 'ps', 'worker'"</span>)</span><br><span class="line">tf.app.flags.DEFINE_integer(<span class="string">"task_index"</span>, <span class="number">0</span>, <span class="string">"Index of task within the job"</span>)</span><br><span class="line">tf.app.flags.DEFINE_integer(<span class="string">"issync"</span>, <span class="number">0</span>, <span class="string">"是否采用分布式的同步模式，1表示同步模式，0表示异步模式"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Hyperparameters</span></span><br><span class="line">learning_rate = FLAGS.learning_rate</span><br><span class="line">steps_to_validate = FLAGS.steps_to_validate</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">(_)</span>:</span></span><br><span class="line">  ps_hosts = FLAGS.ps_hosts.split(<span class="string">","</span>)</span><br><span class="line">  worker_hosts = FLAGS.worker_hosts.split(<span class="string">","</span>)</span><br><span class="line">  cluster = tf.train.ClusterSpec(&#123;<span class="string">"ps"</span>: ps_hosts, <span class="string">"worker"</span>: worker_hosts&#125;)</span><br><span class="line">  <span class="comment">#server = tf.train.Server(cluster,job_name=FLAGS.job_name,task_index=FLAGS.task_index)</span></span><br><span class="line">  server = tf.train.Server(cluster,job_name=FLAGS.job_name,task_index=FLAGS.task_index,protocol=<span class="string">"grpc+verbs"</span>)</span><br><span class="line">  issync = FLAGS.issync</span><br><span class="line">  <span class="keyword">if</span> FLAGS.job_name == <span class="string">"ps"</span>:</span><br><span class="line">    server.join()</span><br><span class="line">  <span class="keyword">elif</span> FLAGS.job_name == <span class="string">"worker"</span>:</span><br><span class="line">    <span class="keyword">with</span> tf.device(tf.train.replica_device_setter(</span><br><span class="line">                    worker_device=<span class="string">"/job:worker/task:%d"</span> % FLAGS.task_index,</span><br><span class="line">                    cluster=cluster)):</span><br><span class="line">      global_step = tf.Variable(<span class="number">0</span>, name=<span class="string">'global_step'</span>, trainable=<span class="keyword">False</span>)</span><br><span class="line"></span><br><span class="line">      input = tf.placeholder(<span class="string">"float"</span>)</span><br><span class="line">      label = tf.placeholder(<span class="string">"float"</span>)</span><br><span class="line"></span><br><span class="line">      weight = tf.get_variable(<span class="string">"weight"</span>, [<span class="number">1</span>], tf.float32, initializer=tf.random_normal_initializer())</span><br><span class="line">      biase  = tf.get_variable(<span class="string">"biase"</span>, [<span class="number">1</span>], tf.float32, initializer=tf.random_normal_initializer())</span><br><span class="line">      pred = tf.multiply(input, weight) + biase</span><br><span class="line"></span><br><span class="line">      loss_value = loss(label, pred)</span><br><span class="line">      optimizer = tf.train.GradientDescentOptimizer(learning_rate)</span><br><span class="line"></span><br><span class="line">      grads_and_vars = optimizer.compute_gradients(loss_value)</span><br><span class="line">      <span class="keyword">if</span> issync == <span class="number">1</span>:</span><br><span class="line">        <span class="comment">#同步模式计算更新梯度</span></span><br><span class="line">        rep_op = tf.train.SyncReplicasOptimizer(optimizer,</span><br><span class="line">                                                replicas_to_aggregate=len(</span><br><span class="line">                                                  worker_hosts),</span><br><span class="line">                                                replica_id=FLAGS.task_index,</span><br><span class="line">                                                total_num_replicas=len(</span><br><span class="line">                                                  worker_hosts),</span><br><span class="line">                                                use_locking=<span class="keyword">True</span>)</span><br><span class="line">        train_op = rep_op.apply_gradients(grads_and_vars,</span><br><span class="line">                                       global_step=global_step)</span><br><span class="line">        init_token_op = rep_op.get_init_tokens_op()</span><br><span class="line">        chief_queue_runner = rep_op.get_chief_queue_runner()</span><br><span class="line">      <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment">#异步模式计算更新梯度</span></span><br><span class="line">        train_op = optimizer.apply_gradients(grads_and_vars,</span><br><span class="line">                                       global_step=global_step)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">      init_op = tf.initialize_all_variables()</span><br><span class="line"></span><br><span class="line">      saver = tf.train.Saver()</span><br><span class="line">      tf.summary.scalar(<span class="string">'cost'</span>, loss_value)</span><br><span class="line">      summary_op = tf.summary.merge_all()</span><br><span class="line"></span><br><span class="line">    sv = tf.train.Supervisor(is_chief=(FLAGS.task_index == <span class="number">0</span>),</span><br><span class="line">                            logdir=<span class="string">"./checkpoint/"</span>,</span><br><span class="line">                            init_op=init_op,</span><br><span class="line">                            summary_op=<span class="keyword">None</span>,</span><br><span class="line">                            saver=saver,</span><br><span class="line">                            global_step=global_step,</span><br><span class="line">                            save_model_secs=<span class="number">60</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">with</span> sv.prepare_or_wait_for_session(server.target) <span class="keyword">as</span> sess:</span><br><span class="line">      <span class="comment"># 如果是同步模式</span></span><br><span class="line">      <span class="keyword">if</span> FLAGS.task_index == <span class="number">0</span> <span class="keyword">and</span> issync == <span class="number">1</span>:</span><br><span class="line">        sv.start_queue_runners(sess, [chief_queue_runner])</span><br><span class="line">        sess.run(init_token_op)</span><br><span class="line">      step = <span class="number">0</span></span><br><span class="line">      <span class="keyword">while</span>  step &lt; <span class="number">1000000</span>:</span><br><span class="line">        train_x = np.random.randn(<span class="number">1</span>)</span><br><span class="line">        train_y = <span class="number">2</span> * train_x + np.random.randn(<span class="number">1</span>) * <span class="number">0.33</span>  + <span class="number">10</span></span><br><span class="line">        _, loss_v, step = sess.run([train_op, loss_value,global_step], feed_dict=&#123;input:train_x, label:train_y&#125;)</span><br><span class="line">        <span class="keyword">if</span> step % steps_to_validate == <span class="number">0</span>:</span><br><span class="line">          w,b = sess.run([weight,biase])</span><br><span class="line">          print(<span class="string">"step: %d, weight: %f, biase: %f, loss: %f"</span> %(step, w, b, loss_v))</span><br><span class="line"></span><br><span class="line">    sv.stop()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">loss</span><span class="params">(label, pred)</span>:</span></span><br><span class="line">  <span class="keyword">return</span> tf.square(label - pred)</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">"__main__"</span>:</span><br><span class="line">  tf.app.run()</span><br></pre></td></tr></table></figure>
<p>PS端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">--rm \</span><br><span class="line">-v nvidia_driver_367.57:/usr/local/nvidia:ro \</span><br><span class="line">--device=/dev/nvidiactl \</span><br><span class="line">--device=/dev/nvidia-uvm \</span><br><span class="line">--device=/dev/nvidia-uvm-tools \</span><br><span class="line">-e LD_LIBRARY_PATH=/usr/local/cuda/extras/CUPTI/lib64:/usr/local/nvidia/lib:/usr/local/nvidia/lib64:/usr/lib/nvidia-375:/usr/lib32/nvidia-375 \</span><br><span class="line">-e LIBRARY_PATH=/usr/local/cuda/lib64/stubs: \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libcuda.so.1:/usr/lib/x86_64-linux-gnu/libcuda.so.1:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libcuda.so.375.39:/usr/lib/x86_64-linux-gnu/libcuda.so.375.39 \</span><br><span class="line">-v /usr/lib32/nvidia-375:/usr/lib32/nvidia-375 \</span><br><span class="line">-v /usr/lib/nvidia-375:/usr/lib/nvidia-375 \</span><br><span class="line">--privileged \</span><br><span class="line">-p 2227:2227 \</span><br><span class="line">-v /etc/libibverbs.d:/etc/libibverbs.d:ro \</span><br><span class="line">-v /usr/lib/libibverbs:/usr/lib/libibverbs:ro \</span><br><span class="line">-v /usr/lib/libibverbs.so.1:/usr/lib/libibverbs.so.1:ro \</span><br><span class="line">-v /usr/lib/librxe-rdmav2.so:/usr/lib/librxe-rdmav2.so:ro \</span><br><span class="line">-v /sys/class/infiniband_verbs:/sys/class/infiniband_verbs:ro \</span><br><span class="line">-v /lib/x86_64-linux-gnu/libnl-3.so.200:/lib/x86_64-linux-gnu/libnl-3.so.200:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libnuma.so.1:/usr/lib/x86_64-linux-gnu/libnuma.so.1:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libnl-route-3.so.200:/usr/lib/x86_64-linux-gnu/libnl-route-3.so.200:ro \</span><br><span class="line">-v /root/TF/distributeTensorflowExample:/Example \</span><br><span class="line">--name rdma-test-ps \</span><br><span class="line">tensorflow:latest-devel-gpu-rdma-hadoop</span><br></pre></td></tr></table></figure>
<p>进入容器后执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Example</span><br><span class="line">CUDA_VISIBLE_DEVICES='' python distribute.py --ps_hosts=0.0.0.0:2227 --worker_hosts=10.42.10.36:2228 --job_name=ps --task_index=0</span><br></pre></td></tr></table></figure>
<p>Worker端</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">docker run -it \</span><br><span class="line">--rm \</span><br><span class="line">-v nvidia_driver_367.57:/usr/local/nvidia:ro \</span><br><span class="line">--device=/dev/nvidiactl \</span><br><span class="line">--device=/dev/nvidia-uvm \</span><br><span class="line">--device=/dev/nvidia-uvm-tools \</span><br><span class="line">-e LD_LIBRARY_PATH=/usr/local/cuda/extras/CUPTI/lib64:/usr/local/nvidia/lib:/usr/local/nvidia/lib64:/usr/lib/nvidia-375:/usr/lib32/nvidia-375 \</span><br><span class="line">-e LIBRARY_PATH=/usr/local/cuda/lib64/stubs: \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libcuda.so.1:/usr/lib/x86_64-linux-gnu/libcuda.so.1:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libcuda.so.375.39:/usr/lib/x86_64-linux-gnu/libcuda.so.375.39 \</span><br><span class="line">-v /usr/lib32/nvidia-375:/usr/lib32/nvidia-375 \</span><br><span class="line">-v /usr/lib/nvidia-375:/usr/lib/nvidia-375 \</span><br><span class="line">--privileged \</span><br><span class="line">-p 2228:2228 \</span><br><span class="line">-v /etc/libibverbs.d:/etc/libibverbs.d:ro \</span><br><span class="line">-v /usr/lib/libibverbs:/usr/lib/libibverbs:ro \</span><br><span class="line">-v /usr/lib/libibverbs.so.1:/usr/lib/libibverbs.so.1:ro \</span><br><span class="line">-v /usr/lib/librxe-rdmav2.so:/usr/lib/librxe-rdmav2.so:ro \</span><br><span class="line">-v /sys/class/infiniband_verbs:/sys/class/infiniband_verbs:ro \</span><br><span class="line">-v /lib/x86_64-linux-gnu/libnl-3.so.200:/lib/x86_64-linux-gnu/libnl-3.so.200:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libnuma.so.1:/usr/lib/x86_64-linux-gnu/libnuma.so.1:ro \</span><br><span class="line">-v /usr/lib/x86_64-linux-gnu/libnl-route-3.so.200:/usr/lib/x86_64-linux-gnu/libnl-route-3.so.200:ro \</span><br><span class="line">-v /root/TF/distributeTensorflowExample:/Example \</span><br><span class="line">--name rdma-test-worker \</span><br><span class="line">tensorflow:latest-devel-gpu-rdma-hadoop</span><br></pre></td></tr></table></figure>
<p>进入容器后执行</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd /Example</span><br><span class="line">CUDA_VISIBLE_DEVICES='' python distribute.py --ps_hosts=10.42.10.36:2227 --worker_hosts=0.0.0.0:2228 --job_name=worker --task_index=0</span><br></pre></td></tr></table></figure>

      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/tensorflow/" rel="tag"># tensorflow</a>
          
            <a href="/tags/rdma/" rel="tag"># rdma</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2017/09/14/mirrors/" rel="next" title="各类镜像加速汇总">
                <i class="fa fa-chevron-left"></i> 各类镜像加速汇总
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2017/09/14/tensorflow-rdma-design/" rel="prev" title="TensorFlow中rdma的设计细节">
                TensorFlow中rdma的设计细节 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            文章目录
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            站点概览
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">linyemin</p>
              <p class="site-description motion-element" itemprop="description">海阔凭鱼跃，天高任鸟飞</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">15</span>
                  <span class="site-state-item-name">分类</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">46</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#rdma-cc"><span class="nav-number">1.</span> <span class="nav-text">rdma.cc</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#相关结构体"><span class="nav-number">1.1.</span> <span class="nav-text">相关结构体</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RdmaAdapter"><span class="nav-number">1.2.</span> <span class="nav-text">RdmaAdapter</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RdmaAdapter-const-WorkerEnv-worker-env"><span class="nav-number">1.2.1.</span> <span class="nav-text">RdmaAdapter(const WorkerEnv* worker_env)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RdmaAdapter-1"><span class="nav-number">1.2.2.</span> <span class="nav-text">~RdmaAdapter()</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#void-Process-CQ"><span class="nav-number">1.2.3.</span> <span class="nav-text">void Process_CQ()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#RdmaChannel"><span class="nav-number">1.3.</span> <span class="nav-text">RdmaChannel</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#RdmaChannel-const-RdmaAdapter-adapter-const-string-local-name-const-string-remotename"><span class="nav-number">1.3.1.</span> <span class="nav-text">RdmaChannel(const RdmaAdapter* adapter, const string local_name, const string remotename)</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RdmaChannel-1"><span class="nav-number">1.3.2.</span> <span class="nav-text">~RdmaChannel()</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#TensorFlow相关"><span class="nav-number">1.4.</span> <span class="nav-text">TensorFlow相关</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#类关系"><span class="nav-number">1.4.1.</span> <span class="nav-text">类关系</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#初始化过程"><span class="nav-number">1.4.2.</span> <span class="nav-text">初始化过程</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#Rendezvous"><span class="nav-number">1.4.3.</span> <span class="nav-text">Rendezvous</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#RendezvousMgr"><span class="nav-number">1.4.4.</span> <span class="nav-text">RendezvousMgr</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#发送"><span class="nav-number">1.4.5.</span> <span class="nav-text">发送</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#接收"><span class="nav-number">1.4.6.</span> <span class="nav-text">接收</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#LOG"><span class="nav-number">1.4.7.</span> <span class="nav-text">LOG</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#结构体"><span class="nav-number">1.4.8.</span> <span class="nav-text">结构体</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#WorkEnv"><span class="nav-number">1.4.8.1.</span> <span class="nav-text">WorkEnv</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#Item"><span class="nav-number">1.4.8.2.</span> <span class="nav-text">Item</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#ParseKey"><span class="nav-number">1.4.8.3.</span> <span class="nav-text">ParseKey</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#调试"><span class="nav-number">1.4.9.</span> <span class="nav-text">调试</span></a></li></ol></li></ol></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">linyemin</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.3"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.3"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.3"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  












  





  

  

  

  
  

  

  

  

</body>
</html>
